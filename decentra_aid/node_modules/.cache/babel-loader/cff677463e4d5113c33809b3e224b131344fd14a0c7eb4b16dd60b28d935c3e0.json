{"ast":null,"code":"\"use strict\";\n\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toBool = exports.toChecksumAddress = exports.toWei = exports.fromWei = exports.toBigInt = exports.toNumber = exports.toHex = exports.toAscii = exports.hexToAscii = exports.fromAscii = exports.asciiToHex = exports.hexToString = exports.utf8ToBytes = exports.toUtf8 = exports.hexToUtf8 = exports.stringToHex = exports.fromUtf8 = exports.utf8ToHex = exports.hexToNumberString = exports.fromDecimal = exports.numberToHex = exports.toDecimal = exports.hexToNumber = exports.hexToBytes = exports.bytesToHex = exports.bytesToUint8Array = exports.ethUnitMap = void 0;\n/**\n * @module Utils\n */\nconst keccak_js_1 = require(\"ethereum-cryptography/keccak.js\");\nconst utils_js_1 = require(\"ethereum-cryptography/utils.js\");\nconst web3_validator_1 = require(\"web3-validator\");\nconst web3_errors_1 = require(\"web3-errors\");\nconst uint8array_js_1 = require(\"./uint8array.js\");\n// Ref: https://ethdocs.org/en/latest/ether.html\n// Note: this could be simplified using ** operator, but babel does not handle it well (https://github.com/babel/babel/issues/13109)\n/** @internal */\nexports.ethUnitMap = {\n  noether: BigInt(0),\n  wei: BigInt(1),\n  kwei: BigInt(1000),\n  Kwei: BigInt(1000),\n  babbage: BigInt(1000),\n  femtoether: BigInt(1000),\n  mwei: BigInt(1000000),\n  Mwei: BigInt(1000000),\n  lovelace: BigInt(1000000),\n  picoether: BigInt(1000000),\n  gwei: BigInt(1000000000),\n  Gwei: BigInt(1000000000),\n  shannon: BigInt(1000000000),\n  nanoether: BigInt(1000000000),\n  nano: BigInt(1000000000),\n  szabo: BigInt(1000000000000),\n  microether: BigInt(1000000000000),\n  micro: BigInt(1000000000000),\n  finney: BigInt(1000000000000000),\n  milliether: BigInt(1000000000000000),\n  milli: BigInt(1000000000000000),\n  ether: BigInt('1000000000000000000'),\n  kether: BigInt('1000000000000000000000'),\n  grand: BigInt('1000000000000000000000'),\n  mether: BigInt('1000000000000000000000000'),\n  gether: BigInt('1000000000000000000000000000'),\n  tether: BigInt('1000000000000000000000000000000')\n};\nconst PrecisionLossWarning = 'Warning: Using type `number` with values that are large or contain many decimals may cause loss of precision, it is recommended to use type `string` or `BigInt` when using conversion methods';\n/**\n * Convert a value from bytes to Uint8Array\n * @param data - Data to be converted\n * @returns - The Uint8Array representation of the input data\n *\n * @example\n * ```ts\n * console.log(web3.utils.bytesToUint8Array(\"0xab\")));\n * > Uint8Array(1) [ 171 ]\n * ```\n */\nconst bytesToUint8Array = data => {\n  web3_validator_1.validator.validate(['bytes'], [data]);\n  if ((0, uint8array_js_1.isUint8Array)(data)) {\n    return data;\n  }\n  if (Array.isArray(data)) {\n    return new Uint8Array(data);\n  }\n  if (typeof data === 'string') {\n    return web3_validator_1.utils.hexToUint8Array(data);\n  }\n  throw new web3_errors_1.InvalidBytesError(data);\n};\nexports.bytesToUint8Array = bytesToUint8Array;\n/**\n * @internal\n */\nconst {\n  uint8ArrayToHexString\n} = web3_validator_1.utils;\n/**\n * Convert a byte array to a hex string\n * @param bytes - Byte array to be converted\n * @returns - The hex string representation of the input byte array\n *\n * @example\n * ```ts\n * console.log(web3.utils.bytesToHex(new Uint8Array([72, 12])));\n * > \"0x480c\"\n *\n */\nconst bytesToHex = bytes => uint8ArrayToHexString((0, exports.bytesToUint8Array)(bytes));\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a hex string to a byte array\n * @param hex - Hex string to be converted\n * @returns - The byte array representation of the input hex string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToBytes('0x74657374'));\n * > Uint8Array(4) [ 116, 101, 115, 116 ]\n * ```\n */\nconst hexToBytes = bytes => {\n  if (typeof bytes === 'string' && bytes.slice(0, 2).toLowerCase() !== '0x') {\n    return (0, exports.bytesToUint8Array)(`0x${bytes}`);\n  }\n  return (0, exports.bytesToUint8Array)(bytes);\n};\nexports.hexToBytes = hexToBytes;\n/**\n * Converts value to it's number representation\n * @param value - Hex string to be converted\n * @returns - The number representation of the input value\n *\n * @example\n * ```ts\n * conoslle.log(web3.utils.hexToNumber('0xa'));\n * > 10\n * ```\n */\nconst hexToNumber = value => {\n  web3_validator_1.validator.validate(['hex'], [value]);\n  // To avoid duplicate code and circular dependency we will\n  // use `hexToNumber` implementation from `web3-validator`\n  return web3_validator_1.utils.hexToNumber(value);\n};\nexports.hexToNumber = hexToNumber;\n/**\n * Converts value to it's number representation @alias `hexToNumber`\n */\nexports.toDecimal = exports.hexToNumber;\n/**\n * Converts value to it's hex representation\n * @param value - Value to be converted\n * @param hexstrict - Add padding to converted value if odd, to make it hexstrict\n * @returns - The hex representation of the input value\n *\n * @example\n * ```ts\n * console.log(web3.utils.numberToHex(10));\n * > \"0xa\"\n * ```\n */\nconst numberToHex = (value, hexstrict) => {\n  if (typeof value !== 'bigint') web3_validator_1.validator.validate(['int'], [value]);\n  // To avoid duplicate code and circular dependency we will\n  // use `numberToHex` implementation from `web3-validator`\n  let updatedValue = web3_validator_1.utils.numberToHex(value);\n  if (hexstrict) {\n    if (!updatedValue.startsWith('-') && updatedValue.length % 2 === 1) {\n      // To avoid duplicate a circular dependency we will not be using the padLeft method\n      updatedValue = '0x0'.concat(updatedValue.slice(2));\n    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith('-')) updatedValue = '-0x0'.concat(updatedValue.slice(3));\n  }\n  return updatedValue;\n};\nexports.numberToHex = numberToHex;\n/**\n * Converts value to it's hex representation @alias `numberToHex`\n *\n */\nexports.fromDecimal = exports.numberToHex;\n/**\n * Converts value to it's decimal representation in string\n * @param value - Hex string to be converted\n * @returns - The decimal representation of the input value\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToNumberString('0xa'));\n * > \"10\"\n * ```\n */\nconst hexToNumberString = data => (0, exports.hexToNumber)(data).toString();\nexports.hexToNumberString = hexToNumberString;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n * @param str - Utf8 string to be converted\n * @returns - The hex representation of the input string\n *\n * @example\n * ```ts\n * console.log(utf8ToHex('web3.js'));\n * > \"0x776562332e6a73\"\n * ```\n *\n */\nconst utf8ToHex = str => {\n  web3_validator_1.validator.validate(['string'], [str]);\n  // To be compatible with 1.x trim null character\n  // eslint-disable-next-line no-control-regex\n  let strWithoutNullCharacter = str.replace(/^(?:\\u0000)/, '');\n  // eslint-disable-next-line no-control-regex\n  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\\u0000)$/, '');\n  return (0, exports.bytesToHex)(new TextEncoder().encode(strWithoutNullCharacter));\n};\nexports.utf8ToHex = utf8ToHex;\n/**\n * @alias utf8ToHex\n */\nexports.fromUtf8 = exports.utf8ToHex;\n/**\n * @alias utf8ToHex\n */\nexports.stringToHex = exports.utf8ToHex;\n/**\n * Should be called to get utf8 from it's hex representation\n * @param str - Hex string to be converted\n * @returns - Utf8 string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToUtf8('0x48656c6c6f20576f726c64'));\n * > Hello World\n * ```\n */\nconst hexToUtf8 = str => (0, utils_js_1.bytesToUtf8)((0, exports.hexToBytes)(str));\nexports.hexToUtf8 = hexToUtf8;\n/**\n * @alias hexToUtf8\n */\nconst toUtf8 = input => {\n  if (typeof input === 'string') {\n    return (0, exports.hexToUtf8)(input);\n  }\n  web3_validator_1.validator.validate(['bytes'], [input]);\n  return (0, utils_js_1.bytesToUtf8)(input);\n};\nexports.toUtf8 = toUtf8;\nexports.utf8ToBytes = utils_js_1.utf8ToBytes;\n/**\n * @alias hexToUtf8\n */\nexports.hexToString = exports.hexToUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n * @param str - String to be converted to hex\n * @returns - Hex string\n *\n * @example\n * ```ts\n * console.log(web3.utils.asciiToHex('Hello World'));\n * > 0x48656c6c6f20576f726c64\n * ```\n */\nconst asciiToHex = str => {\n  web3_validator_1.validator.validate(['string'], [str]);\n  let hexString = '';\n  for (let i = 0; i < str.length; i += 1) {\n    const hexCharCode = str.charCodeAt(i).toString(16);\n    // might need a leading 0\n    hexString += hexCharCode.length % 2 !== 0 ? `0${hexCharCode}` : hexCharCode;\n  }\n  return `0x${hexString}`;\n};\nexports.asciiToHex = asciiToHex;\n/**\n * @alias asciiToHex\n */\nexports.fromAscii = exports.asciiToHex;\n/**\n * Should be called to get ascii from it's hex representation\n * @param str - Hex string to be converted to ascii\n * @returns - Ascii string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToAscii('0x48656c6c6f20576f726c64'));\n * > Hello World\n * ```\n */\nconst hexToAscii = str => {\n  const decoder = new TextDecoder('ascii');\n  return decoder.decode((0, exports.hexToBytes)(str));\n};\nexports.hexToAscii = hexToAscii;\n/**\n * @alias hexToAscii\n */\nexports.toAscii = exports.hexToAscii;\n/**\n * Auto converts any given value into it's hex representation.\n * @param value - Value to be converted to hex\n * @param returnType - If true, it will return the type of the value\n *\n * @example\n * ```ts\n * console.log(web3.utils.toHex(10));\n * > 0xa\n *\n * console.log(web3.utils.toHex('0x123', true));\n * > bytes\n *```\n */\nconst toHex = (value, returnType) => {\n  if (typeof value === 'string' && (0, web3_validator_1.isAddress)(value)) {\n    return returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`;\n  }\n  if (typeof value === 'boolean') {\n    // eslint-disable-next-line no-nested-ternary\n    return returnType ? 'bool' : value ? '0x01' : '0x00';\n  }\n  if (typeof value === 'number') {\n    // eslint-disable-next-line no-nested-ternary\n    return returnType ? value < 0 ? 'int256' : 'uint256' : (0, exports.numberToHex)(value);\n  }\n  if (typeof value === 'bigint') {\n    return returnType ? 'bigint' : (0, exports.numberToHex)(value);\n  }\n  if ((0, uint8array_js_1.isUint8Array)(value)) {\n    return returnType ? 'bytes' : (0, exports.bytesToHex)(value);\n  }\n  if (typeof value === 'object' && !!value) {\n    return returnType ? 'string' : (0, exports.utf8ToHex)(JSON.stringify(value));\n  }\n  if (typeof value === 'string') {\n    if (value.startsWith('-0x') || value.startsWith('-0X')) {\n      return returnType ? 'int256' : (0, exports.numberToHex)(value);\n    }\n    if ((0, web3_validator_1.isHexStrict)(value)) {\n      return returnType ? 'bytes' : value;\n    }\n    if ((0, web3_validator_1.isHex)(value) && !(0, web3_validator_1.isInt)(value) && !(0, web3_validator_1.isUInt)(value)) {\n      return returnType ? 'bytes' : `0x${value}`;\n    }\n    if ((0, web3_validator_1.isHex)(value) && !(0, web3_validator_1.isInt)(value) && (0, web3_validator_1.isUInt)(value)) {\n      // This condition seems problematic because meeting\n      // both conditions `!isInt(value) && isUInt(value)` should be impossible.\n      // But a value pass for those conditions: \"101611154195520776335741463917853444671577865378275924493376429267637792638729\"\n      // Note that according to the docs: it is supposed to be treated as a string (https://docs.web3js.org/guides/web3_upgrade_guide/x/web3_utils_migration_guide#conversion-to-hex)\n      // In short, the strange is that isInt(value) is false but isUInt(value) is true for the value above.\n      // TODO: isUInt(value) should be investigated.\n      // However, if `toHex('101611154195520776335741463917853444671577865378275924493376429267637792638729', true)` is called, it will return `true`.\n      // But, if `toHex('101611154195520776335741463917853444671577865378275924493376429267637792638729')` is called, it will throw inside `numberToHex`.\n      return returnType ? 'uint' : (0, exports.numberToHex)(value);\n    }\n    if (!Number.isFinite(value)) {\n      return returnType ? 'string' : (0, exports.utf8ToHex)(value);\n    }\n  }\n  throw new web3_errors_1.HexProcessingError(value);\n};\nexports.toHex = toHex;\n/**\n * Converts any given value into it's number representation, if possible, else into it's bigint representation.\n * @param value - The value to convert\n * @returns - Returns the value in number or bigint representation\n *\n * @example\n * ```ts\n * console.log(web3.utils.toNumber(1));\n * > 1\n * console.log(web3.utils.toNumber(Number.MAX_SAFE_INTEGER));\n * > 9007199254740991\n *\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER)));\n * > 9007199254740991\n *\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)));\n * > 9007199254740992n\n *\n * ```\n */\nconst toNumber = value => {\n  if (typeof value === 'number') {\n    if (value > 1e20) {\n      console.warn(PrecisionLossWarning);\n      // JavaScript converts numbers >= 10^21 to scientific notation when coerced to strings,\n      // leading to potential parsing errors and incorrect representations.\n      // For instance, String(10000000000000000000000) yields '1e+22'.\n      // Using BigInt prevents this\n      return BigInt(value);\n    }\n    return value;\n  }\n  if (typeof value === 'bigint') {\n    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;\n  }\n  if (typeof value === 'string' && (0, web3_validator_1.isHexStrict)(value)) {\n    return (0, exports.hexToNumber)(value);\n  }\n  try {\n    return (0, exports.toNumber)(BigInt(value));\n  } catch (_a) {\n    throw new web3_errors_1.InvalidNumberError(value);\n  }\n};\nexports.toNumber = toNumber;\n/**\n * Auto converts any given value into it's bigint representation\n *\n * @param value - The value to convert\n * @returns - Returns the value in bigint representation\n\n * @example\n * ```ts\n * console.log(web3.utils.toBigInt(1));\n * > 1n\n * ```\n */\nconst toBigInt = value => {\n  if (typeof value === 'number') {\n    return BigInt(value);\n  }\n  if (typeof value === 'bigint') {\n    return value;\n  }\n  // isHex passes for dec, too\n  if (typeof value === 'string' && (0, web3_validator_1.isHex)(value)) {\n    if (value.startsWith('-')) {\n      return -BigInt(value.substring(1));\n    }\n    return BigInt(value);\n  }\n  throw new web3_errors_1.InvalidNumberError(value);\n};\nexports.toBigInt = toBigInt;\n/**\n * Takes a number of wei and converts it to any other ether unit.\n * @param number - The value in wei\n * @param unit - The unit to convert to\n * @returns - Returns the converted value in the given unit\n *\n * @example\n * ```ts\n * console.log(web3.utils.fromWei(\"1\", \"ether\"));\n * > 0.000000000000000001\n *\n * console.log(web3.utils.fromWei(\"1\", \"shannon\"));\n * > 0.000000001\n * ```\n */\nconst fromWei = (number, unit) => {\n  let denomination;\n  if (typeof unit === 'string') {\n    denomination = exports.ethUnitMap[unit];\n    if (!denomination) {\n      throw new web3_errors_1.InvalidUnitError(unit);\n    }\n  } else {\n    if (unit < 0 || !Number.isInteger(unit)) {\n      throw new web3_errors_1.InvalidIntegerError(unit);\n    }\n    denomination = (0, web3_validator_1.bigintPower)(BigInt(10), BigInt(unit));\n  }\n  // value in wei would always be integer\n  // 13456789, 1234\n  const value = String((0, exports.toNumber)(number));\n  // count number of zeros in denomination\n  // 1000000 -> 6\n  const numberOfZerosInDenomination = denomination.toString().length - 1;\n  if (numberOfZerosInDenomination <= 0) {\n    return value.toString();\n  }\n  // pad the value with required zeros\n  // 13456789 -> 13456789, 1234 -> 001234\n  const zeroPaddedValue = value.padStart(numberOfZerosInDenomination, '0');\n  // get the integer part of value by counting number of zeros from start\n  // 13456789 -> '13'\n  // 001234 -> ''\n  const integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination);\n  // get the fraction part of value by counting number of zeros backward\n  // 13456789 -> '456789'\n  // 001234 -> '001234'\n  const fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\\.?0+$/, '');\n  if (integer === '') {\n    return fraction ? `0.${fraction}` : '0';\n  }\n  if (fraction === '') {\n    return integer;\n  }\n  const updatedValue = `${integer}.${fraction}`;\n  return updatedValue.slice(0, integer.length + numberOfZerosInDenomination + 1);\n};\nexports.fromWei = fromWei;\n/**\n * Takes a number of a unit and converts it to wei.\n *\n * @param number - The number to convert.\n * @param unit - {@link EtherUnits} The unit of the number passed.\n * @returns The number converted to wei.\n *\n * @example\n * ```ts\n * console.log(web3.utils.toWei(\"0.001\", \"ether\"));\n * > 1000000000000000 //(wei)\n * ```\n */\n// todo in 1.x unit defaults to 'ether'\nconst toWei = (number, unit) => {\n  web3_validator_1.validator.validate(['number'], [number]);\n  let denomination;\n  if (typeof unit === 'string') {\n    denomination = exports.ethUnitMap[unit];\n    if (!denomination) {\n      throw new web3_errors_1.InvalidUnitError(unit);\n    }\n  } else {\n    if (unit < 0 || !Number.isInteger(unit)) {\n      throw new web3_errors_1.InvalidIntegerError(unit);\n    }\n    denomination = (0, web3_validator_1.bigintPower)(BigInt(10), BigInt(unit));\n  }\n  let parsedNumber = number;\n  if (typeof parsedNumber === 'number') {\n    if (parsedNumber < 1e-15) {\n      console.warn(PrecisionLossWarning);\n    }\n    if (parsedNumber > 1e20) {\n      console.warn(PrecisionLossWarning);\n      parsedNumber = BigInt(parsedNumber);\n    } else {\n      // in case there is a decimal point, we need to convert it to string\n      parsedNumber = parsedNumber.toLocaleString('fullwide', {\n        useGrouping: false,\n        maximumFractionDigits: 20\n      });\n    }\n  }\n  // if value is decimal e.g. 24.56 extract `integer` and `fraction` part\n  // to avoid `fraction` to be null use `concat` with empty string\n  const [integer, fraction] = String(typeof parsedNumber === 'string' && !(0, web3_validator_1.isHexStrict)(parsedNumber) ? parsedNumber : (0, exports.toNumber)(parsedNumber)).split('.').concat('');\n  // join the value removing `.` from\n  // 24.56 -> 2456\n  const value = BigInt(`${integer}${fraction}`);\n  // multiply value with denomination\n  // 2456 * 1000000 -> 2456000000\n  const updatedValue = value * denomination;\n  // check if whole number was passed in\n  const decimals = fraction.length;\n  if (decimals === 0) {\n    return updatedValue.toString();\n  }\n  // trim the value to remove extra zeros\n  return updatedValue.toString().slice(0, -decimals);\n};\nexports.toWei = toWei;\n/**\n * Will convert an upper or lowercase Ethereum address to a checksum address.\n * @param address - An address string\n * @returns\tThe checksum address\n * @example\n * ```ts\n * web3.utils.toChecksumAddress('0xc1912fee45d61c87cc5ea59dae31190fffff232d');\n * > \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\"\n * ```\n */\nconst toChecksumAddress = address => {\n  if (!(0, web3_validator_1.isAddress)(address, false)) {\n    throw new web3_errors_1.InvalidAddressError(address);\n  }\n  const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, '');\n  // calling `Uint8Array.from` because `noble-hashes` checks with `instanceof Uint8Array` that fails in some edge cases:\n  // \thttps://github.com/paulmillr/noble-hashes/issues/25#issuecomment-1750106284\n  const hash = web3_validator_1.utils.uint8ArrayToHexString((0, keccak_js_1.keccak256)(web3_validator_1.utils.ensureIfUint8Array((0, exports.utf8ToBytes)(lowerCaseAddress))));\n  if ((0, web3_validator_1.isNullish)(hash) || hash === '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470') return ''; // // EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\n  let checksumAddress = '0x';\n  const addressHash = hash.replace(/^0x/i, '');\n  for (let i = 0; i < lowerCaseAddress.length; i += 1) {\n    // If ith character is 8 to f then make it uppercase\n    if (parseInt(addressHash[i], 16) > 7) {\n      checksumAddress += lowerCaseAddress[i].toUpperCase();\n    } else {\n      checksumAddress += lowerCaseAddress[i];\n    }\n  }\n  return checksumAddress;\n};\nexports.toChecksumAddress = toChecksumAddress;\nconst toBool = value => {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n  if (typeof value === 'number' && (value === 0 || value === 1)) {\n    return Boolean(value);\n  }\n  if (typeof value === 'bigint' && (value === BigInt(0) || value === BigInt(1))) {\n    return Boolean(value);\n  }\n  if (typeof value === 'string' && !(0, web3_validator_1.isHexStrict)(value) && (value === '1' || value === '0' || value === 'false' || value === 'true')) {\n    if (value === 'true') {\n      return true;\n    }\n    if (value === 'false') {\n      return false;\n    }\n    return Boolean(Number(value));\n  }\n  if (typeof value === 'string' && (0, web3_validator_1.isHexStrict)(value) && (value === '0x1' || value === '0x0')) {\n    return Boolean((0, exports.toNumber)(value));\n  }\n  throw new web3_errors_1.InvalidBooleanError(value);\n};\nexports.toBool = toBool;","map":{"version":3,"names":["keccak_js_1","require","utils_js_1","web3_validator_1","web3_errors_1","uint8array_js_1","exports","ethUnitMap","noether","BigInt","wei","kwei","Kwei","babbage","femtoether","mwei","Mwei","lovelace","picoether","gwei","Gwei","shannon","nanoether","nano","szabo","microether","micro","finney","milliether","milli","ether","kether","grand","mether","gether","tether","PrecisionLossWarning","bytesToUint8Array","data","validator","validate","isUint8Array","Array","isArray","Uint8Array","utils","hexToUint8Array","InvalidBytesError","uint8ArrayToHexString","bytesToHex","bytes","hexToBytes","slice","toLowerCase","hexToNumber","value","toDecimal","numberToHex","hexstrict","updatedValue","startsWith","length","concat","fromDecimal","hexToNumberString","toString","utf8ToHex","str","strWithoutNullCharacter","replace","TextEncoder","encode","fromUtf8","stringToHex","hexToUtf8","bytesToUtf8","toUtf8","input","utf8ToBytes","hexToString","asciiToHex","hexString","i","hexCharCode","charCodeAt","fromAscii","hexToAscii","decoder","TextDecoder","decode","toAscii","toHex","returnType","isAddress","JSON","stringify","isHexStrict","isHex","isInt","isUInt","Number","isFinite","HexProcessingError","toNumber","console","warn","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","_a","InvalidNumberError","toBigInt","substring","fromWei","number","unit","denomination","InvalidUnitError","isInteger","InvalidIntegerError","bigintPower","String","numberOfZerosInDenomination","zeroPaddedValue","padStart","integer","fraction","toWei","parsedNumber","toLocaleString","useGrouping","maximumFractionDigits","split","decimals","toChecksumAddress","address","InvalidAddressError","lowerCaseAddress","hash","keccak256","ensureIfUint8Array","isNullish","checksumAddress","addressHash","parseInt","toUpperCase","toBool","Boolean","InvalidBooleanError"],"sources":["/home/nathan/node_modules/web3-utils/src/converters.ts"],"sourcesContent":["﻿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @module Utils\n */\n\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { bytesToUtf8, utf8ToBytes as ecUtf8ToBytes } from 'ethereum-cryptography/utils.js';\nimport { Address, Bytes, HexString, Numbers, ValueTypes } from 'web3-types';\nimport {\n\tisAddress,\n\tisHex,\n\tisHexStrict,\n\tisInt,\n\tisUInt,\n\tisNullish,\n\tutils,\n\tutils as validatorUtils,\n\tvalidator,\n\tbigintPower,\n} from 'web3-validator';\n\nimport {\n\tHexProcessingError,\n\tInvalidAddressError,\n\tInvalidBooleanError,\n\tInvalidBytesError,\n\tInvalidNumberError,\n\tInvalidUnitError,\n\tInvalidIntegerError,\n} from 'web3-errors';\nimport { isUint8Array } from './uint8array.js';\n\n// Ref: https://ethdocs.org/en/latest/ether.html\n// Note: this could be simplified using ** operator, but babel does not handle it well (https://github.com/babel/babel/issues/13109)\n/** @internal */\nexport const ethUnitMap = {\n\tnoether: BigInt(0),\n\twei: BigInt(1),\n\tkwei: BigInt(1000),\n\tKwei: BigInt(1000),\n\tbabbage: BigInt(1000),\n\tfemtoether: BigInt(1000),\n\tmwei: BigInt(1000000),\n\tMwei: BigInt(1000000),\n\tlovelace: BigInt(1000000),\n\tpicoether: BigInt(1000000),\n\tgwei: BigInt(1000000000),\n\tGwei: BigInt(1000000000),\n\tshannon: BigInt(1000000000),\n\tnanoether: BigInt(1000000000),\n\tnano: BigInt(1000000000),\n\tszabo: BigInt(1000000000000),\n\tmicroether: BigInt(1000000000000),\n\tmicro: BigInt(1000000000000),\n\tfinney: BigInt(1000000000000000),\n\tmilliether: BigInt(1000000000000000),\n\tmilli: BigInt(1000000000000000),\n\tether: BigInt('1000000000000000000'),\n\tkether: BigInt('1000000000000000000000'),\n\tgrand: BigInt('1000000000000000000000'),\n\tmether: BigInt('1000000000000000000000000'),\n\tgether: BigInt('1000000000000000000000000000'),\n\ttether: BigInt('1000000000000000000000000000000'),\n};\n\nconst PrecisionLossWarning =\n\t'Warning: Using type `number` with values that are large or contain many decimals may cause loss of precision, it is recommended to use type `string` or `BigInt` when using conversion methods';\n\nexport type EtherUnits = keyof typeof ethUnitMap;\n/**\n * Convert a value from bytes to Uint8Array\n * @param data - Data to be converted\n * @returns - The Uint8Array representation of the input data\n *\n * @example\n * ```ts\n * console.log(web3.utils.bytesToUint8Array(\"0xab\")));\n * > Uint8Array(1) [ 171 ]\n * ```\n */\nexport const bytesToUint8Array = (data: Bytes): Uint8Array | never => {\n\tvalidator.validate(['bytes'], [data]);\n\n\tif (isUint8Array(data)) {\n\t\treturn data;\n\t}\n\n\tif (Array.isArray(data)) {\n\t\treturn new Uint8Array(data);\n\t}\n\n\tif (typeof data === 'string') {\n\t\treturn validatorUtils.hexToUint8Array(data);\n\t}\n\n\tthrow new InvalidBytesError(data);\n};\n\n/**\n * @internal\n */\nconst { uint8ArrayToHexString } = validatorUtils;\n\n/**\n * Convert a byte array to a hex string\n * @param bytes - Byte array to be converted\n * @returns - The hex string representation of the input byte array\n *\n * @example\n * ```ts\n * console.log(web3.utils.bytesToHex(new Uint8Array([72, 12])));\n * > \"0x480c\"\n *\n */\nexport const bytesToHex = (bytes: Bytes): HexString =>\n\tuint8ArrayToHexString(bytesToUint8Array(bytes));\n\n/**\n * Convert a hex string to a byte array\n * @param hex - Hex string to be converted\n * @returns - The byte array representation of the input hex string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToBytes('0x74657374'));\n * > Uint8Array(4) [ 116, 101, 115, 116 ]\n * ```\n */\nexport const hexToBytes = (bytes: HexString): Uint8Array => {\n\tif (typeof bytes === 'string' && bytes.slice(0, 2).toLowerCase() !== '0x') {\n\t\treturn bytesToUint8Array(`0x${bytes}`);\n\t}\n\treturn bytesToUint8Array(bytes);\n};\n\n/**\n * Converts value to it's number representation\n * @param value - Hex string to be converted\n * @returns - The number representation of the input value\n *\n * @example\n * ```ts\n * conoslle.log(web3.utils.hexToNumber('0xa'));\n * > 10\n * ```\n */\nexport const hexToNumber = (value: HexString): bigint | number => {\n\tvalidator.validate(['hex'], [value]);\n\n\t// To avoid duplicate code and circular dependency we will\n\t// use `hexToNumber` implementation from `web3-validator`\n\treturn validatorUtils.hexToNumber(value);\n};\n\n/**\n * Converts value to it's number representation @alias `hexToNumber`\n */\nexport const toDecimal = hexToNumber;\n\n/**\n * Converts value to it's hex representation\n * @param value - Value to be converted\n * @param hexstrict - Add padding to converted value if odd, to make it hexstrict\n * @returns - The hex representation of the input value\n *\n * @example\n * ```ts\n * console.log(web3.utils.numberToHex(10));\n * > \"0xa\"\n * ```\n */\nexport const numberToHex = (value: Numbers, hexstrict?: boolean): HexString => {\n\tif (typeof value !== 'bigint') validator.validate(['int'], [value]);\n\t// To avoid duplicate code and circular dependency we will\n\t// use `numberToHex` implementation from `web3-validator`\n\tlet updatedValue = validatorUtils.numberToHex(value);\n\tif (hexstrict) {\n\t\tif (!updatedValue.startsWith('-') && updatedValue.length % 2 === 1) {\n\t\t\t// To avoid duplicate a circular dependency we will not be using the padLeft method\n\t\t\tupdatedValue = '0x0'.concat(updatedValue.slice(2));\n\t\t} else if (updatedValue.length % 2 === 0 && updatedValue.startsWith('-'))\n\t\t\tupdatedValue = '-0x0'.concat(updatedValue.slice(3));\n\t}\n\treturn updatedValue;\n};\n/**\n * Converts value to it's hex representation @alias `numberToHex`\n *\n */\nexport const fromDecimal = numberToHex;\n\n/**\n * Converts value to it's decimal representation in string\n * @param value - Hex string to be converted\n * @returns - The decimal representation of the input value\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToNumberString('0xa'));\n * > \"10\"\n * ```\n */\nexport const hexToNumberString = (data: HexString): string => hexToNumber(data).toString();\n\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n * @param str - Utf8 string to be converted\n * @returns - The hex representation of the input string\n *\n * @example\n * ```ts\n * console.log(utf8ToHex('web3.js'));\n * > \"0x776562332e6a73\"\n * ```\n *\n */\nexport const utf8ToHex = (str: string): HexString => {\n\tvalidator.validate(['string'], [str]);\n\n\t// To be compatible with 1.x trim null character\n\t// eslint-disable-next-line no-control-regex\n\tlet strWithoutNullCharacter = str.replace(/^(?:\\u0000)/, '');\n\t// eslint-disable-next-line no-control-regex\n\tstrWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\\u0000)$/, '');\n\n\treturn bytesToHex(new TextEncoder().encode(strWithoutNullCharacter));\n};\n\n/**\n * @alias utf8ToHex\n */\n\nexport const fromUtf8 = utf8ToHex;\n/**\n * @alias utf8ToHex\n */\nexport const stringToHex = utf8ToHex;\n\n/**\n * Should be called to get utf8 from it's hex representation\n * @param str - Hex string to be converted\n * @returns - Utf8 string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToUtf8('0x48656c6c6f20576f726c64'));\n * > Hello World\n * ```\n */\nexport const hexToUtf8 = (str: HexString): string => bytesToUtf8(hexToBytes(str));\n\n/**\n * @alias hexToUtf8\n */\nexport const toUtf8 = (input: HexString | Uint8Array) => {\n\tif (typeof input === 'string') {\n\t\treturn hexToUtf8(input);\n\t}\n\tvalidator.validate(['bytes'], [input]);\n\treturn bytesToUtf8(input);\n};\n\nexport const utf8ToBytes = ecUtf8ToBytes;\n\n/**\n * @alias hexToUtf8\n */\nexport const hexToString = hexToUtf8;\n\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n * @param str - String to be converted to hex\n * @returns - Hex string\n *\n * @example\n * ```ts\n * console.log(web3.utils.asciiToHex('Hello World'));\n * > 0x48656c6c6f20576f726c64\n * ```\n */\nexport const asciiToHex = (str: string): HexString => {\n\tvalidator.validate(['string'], [str]);\n\tlet hexString = '';\n\tfor (let i = 0; i < str.length; i += 1) {\n\t\tconst hexCharCode = str.charCodeAt(i).toString(16);\n\t\t// might need a leading 0\n\t\thexString += hexCharCode.length % 2 !== 0 ? `0${hexCharCode}` : hexCharCode;\n\t}\n\treturn `0x${hexString}`;\n};\n\n/**\n * @alias asciiToHex\n */\nexport const fromAscii = asciiToHex;\n\n/**\n * Should be called to get ascii from it's hex representation\n * @param str - Hex string to be converted to ascii\n * @returns - Ascii string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToAscii('0x48656c6c6f20576f726c64'));\n * > Hello World\n * ```\n */\nexport const hexToAscii = (str: HexString): string => {\n\tconst decoder = new TextDecoder('ascii');\n\treturn decoder.decode(hexToBytes(str));\n};\n\n/**\n * @alias hexToAscii\n */\nexport const toAscii = hexToAscii;\n\n/**\n * Auto converts any given value into it's hex representation.\n * @param value - Value to be converted to hex\n * @param returnType - If true, it will return the type of the value\n *\n * @example\n * ```ts\n * console.log(web3.utils.toHex(10));\n * > 0xa\n *\n * console.log(web3.utils.toHex('0x123', true));\n * > bytes\n *```\n */\nexport const toHex = (\n\tvalue: Numbers | Bytes | Address | boolean | object,\n\treturnType?: boolean,\n): HexString | ValueTypes => {\n\tif (typeof value === 'string' && isAddress(value)) {\n\t\treturn returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`;\n\t}\n\n\tif (typeof value === 'boolean') {\n\t\t// eslint-disable-next-line no-nested-ternary\n\t\treturn returnType ? 'bool' : value ? '0x01' : '0x00';\n\t}\n\n\tif (typeof value === 'number') {\n\t\t// eslint-disable-next-line no-nested-ternary\n\t\treturn returnType ? (value < 0 ? 'int256' : 'uint256') : numberToHex(value);\n\t}\n\n\tif (typeof value === 'bigint') {\n\t\treturn returnType ? 'bigint' : numberToHex(value);\n\t}\n\n\tif (isUint8Array(value)) {\n\t\treturn returnType ? 'bytes' : bytesToHex(value);\n\t}\n\n\tif (typeof value === 'object' && !!value) {\n\t\treturn returnType ? 'string' : utf8ToHex(JSON.stringify(value));\n\t}\n\n\tif (typeof value === 'string') {\n\t\tif (value.startsWith('-0x') || value.startsWith('-0X')) {\n\t\t\treturn returnType ? 'int256' : numberToHex(value);\n\t\t}\n\n\t\tif (isHexStrict(value)) {\n\t\t\treturn returnType ? 'bytes' : value;\n\t\t}\n\t\tif (isHex(value) && !isInt(value) && !isUInt(value)) {\n\t\t\treturn returnType ? 'bytes' : `0x${value}`;\n\t\t}\n\t\tif (isHex(value) && !isInt(value) && isUInt(value)) {\n\t\t\t// This condition seems problematic because meeting\n\t\t\t// both conditions `!isInt(value) && isUInt(value)` should be impossible.\n\t\t\t// But a value pass for those conditions: \"101611154195520776335741463917853444671577865378275924493376429267637792638729\"\n\t\t\t// Note that according to the docs: it is supposed to be treated as a string (https://docs.web3js.org/guides/web3_upgrade_guide/x/web3_utils_migration_guide#conversion-to-hex)\n\t\t\t// In short, the strange is that isInt(value) is false but isUInt(value) is true for the value above.\n\t\t\t// TODO: isUInt(value) should be investigated.\n\n\t\t\t// However, if `toHex('101611154195520776335741463917853444671577865378275924493376429267637792638729', true)` is called, it will return `true`.\n\t\t\t// But, if `toHex('101611154195520776335741463917853444671577865378275924493376429267637792638729')` is called, it will throw inside `numberToHex`.\n\t\t\treturn returnType ? 'uint' : numberToHex(value);\n\t\t}\n\n\t\tif (!Number.isFinite(value)) {\n\t\t\treturn returnType ? 'string' : utf8ToHex(value);\n\t\t}\n\t}\n\n\tthrow new HexProcessingError(value);\n};\n\n/**\n * Converts any given value into it's number representation, if possible, else into it's bigint representation.\n * @param value - The value to convert\n * @returns - Returns the value in number or bigint representation\n *\n * @example\n * ```ts\n * console.log(web3.utils.toNumber(1));\n * > 1\n * console.log(web3.utils.toNumber(Number.MAX_SAFE_INTEGER));\n * > 9007199254740991\n *\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER)));\n * > 9007199254740991\n *\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)));\n * > 9007199254740992n\n *\n * ```\n */\nexport const toNumber = (value: Numbers): number | bigint => {\n\tif (typeof value === 'number') {\n\t\tif (value > 1e20) {\n\t\t\tconsole.warn(PrecisionLossWarning);\n\t\t\t// JavaScript converts numbers >= 10^21 to scientific notation when coerced to strings,\n\t\t\t// leading to potential parsing errors and incorrect representations.\n\t\t\t// For instance, String(10000000000000000000000) yields '1e+22'.\n\t\t\t// Using BigInt prevents this\n\t\t\treturn BigInt(value);\n\t\t}\n\t\treturn value;\n\t}\n\n\tif (typeof value === 'bigint') {\n\t\treturn value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER\n\t\t\t? Number(value)\n\t\t\t: value;\n\t}\n\n\tif (typeof value === 'string' && isHexStrict(value)) {\n\t\treturn hexToNumber(value);\n\t}\n\n\ttry {\n\t\treturn toNumber(BigInt(value));\n\t} catch {\n\t\tthrow new InvalidNumberError(value);\n\t}\n};\n\n/**\n * Auto converts any given value into it's bigint representation\n *\n * @param value - The value to convert\n * @returns - Returns the value in bigint representation\n\n * @example\n * ```ts\n * console.log(web3.utils.toBigInt(1));\n * > 1n\n * ```\n */\nexport const toBigInt = (value: unknown): bigint => {\n\tif (typeof value === 'number') {\n\t\treturn BigInt(value);\n\t}\n\n\tif (typeof value === 'bigint') {\n\t\treturn value;\n\t}\n\n\t// isHex passes for dec, too\n\tif (typeof value === 'string' && isHex(value)) {\n\t\tif (value.startsWith('-')) {\n\t\t\treturn -BigInt(value.substring(1));\n\t\t}\n\t\treturn BigInt(value);\n\t}\n\n\tthrow new InvalidNumberError(value);\n};\n\n/**\n * Takes a number of wei and converts it to any other ether unit.\n * @param number - The value in wei\n * @param unit - The unit to convert to\n * @returns - Returns the converted value in the given unit\n *\n * @example\n * ```ts\n * console.log(web3.utils.fromWei(\"1\", \"ether\"));\n * > 0.000000000000000001\n *\n * console.log(web3.utils.fromWei(\"1\", \"shannon\"));\n * > 0.000000001\n * ```\n */\nexport const fromWei = (number: Numbers, unit: EtherUnits | number): string => {\n\tlet denomination;\n\tif (typeof unit === 'string') {\n\t\tdenomination = ethUnitMap[unit];\n\n\t\tif (!denomination) {\n\t\t\tthrow new InvalidUnitError(unit);\n\t\t}\n\t} else {\n\t\tif (unit < 0 || !Number.isInteger(unit)) {\n\t\t\tthrow new InvalidIntegerError(unit);\n\t\t}\n\t\tdenomination = bigintPower(BigInt(10), BigInt(unit));\n\t}\n\n\t// value in wei would always be integer\n\t// 13456789, 1234\n\tconst value = String(toNumber(number));\n\n\t// count number of zeros in denomination\n\t// 1000000 -> 6\n\tconst numberOfZerosInDenomination = denomination.toString().length - 1;\n\n\tif (numberOfZerosInDenomination <= 0) {\n\t\treturn value.toString();\n\t}\n\n\t// pad the value with required zeros\n\t// 13456789 -> 13456789, 1234 -> 001234\n\tconst zeroPaddedValue = value.padStart(numberOfZerosInDenomination, '0');\n\n\t// get the integer part of value by counting number of zeros from start\n\t// 13456789 -> '13'\n\t// 001234 -> ''\n\tconst integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination);\n\n\t// get the fraction part of value by counting number of zeros backward\n\t// 13456789 -> '456789'\n\t// 001234 -> '001234'\n\tconst fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\\.?0+$/, '');\n\n\tif (integer === '') {\n\t\treturn fraction ? `0.${fraction}` : '0';\n\t}\n\n\tif (fraction === '') {\n\t\treturn integer;\n\t}\n\tconst updatedValue = `${integer}.${fraction}`;\n\n\treturn updatedValue.slice(0, integer.length + numberOfZerosInDenomination + 1);\n};\n\n/**\n * Takes a number of a unit and converts it to wei.\n *\n * @param number - The number to convert.\n * @param unit - {@link EtherUnits} The unit of the number passed.\n * @returns The number converted to wei.\n *\n * @example\n * ```ts\n * console.log(web3.utils.toWei(\"0.001\", \"ether\"));\n * > 1000000000000000 //(wei)\n * ```\n */\n// todo in 1.x unit defaults to 'ether'\nexport const toWei = (number: Numbers, unit: EtherUnits | number): string => {\n\tvalidator.validate(['number'], [number]);\n\n\tlet denomination;\n\tif (typeof unit === 'string') {\n\t\tdenomination = ethUnitMap[unit];\n\t\tif (!denomination) {\n\t\t\tthrow new InvalidUnitError(unit);\n\t\t}\n\t} else {\n\t\tif (unit < 0 || !Number.isInteger(unit)) {\n\t\t\tthrow new InvalidIntegerError(unit);\n\t\t}\n\n\t\tdenomination = bigintPower(BigInt(10), BigInt(unit));\n\t}\n\n\tlet parsedNumber = number;\n\tif (typeof parsedNumber === 'number') {\n\t\tif (parsedNumber < 1e-15) {\n\t\t\tconsole.warn(PrecisionLossWarning);\n\t\t}\n\t\tif (parsedNumber > 1e20) {\n\t\t\tconsole.warn(PrecisionLossWarning);\n\n\t\t\tparsedNumber = BigInt(parsedNumber);\n\t\t} else {\n\t\t\t// in case there is a decimal point, we need to convert it to string\n\t\t\tparsedNumber = parsedNumber.toLocaleString('fullwide', {\n\t\t\t\tuseGrouping: false,\n\t\t\t\tmaximumFractionDigits: 20,\n\t\t\t});\n\t\t}\n\t}\n\n\t// if value is decimal e.g. 24.56 extract `integer` and `fraction` part\n\t// to avoid `fraction` to be null use `concat` with empty string\n\tconst [integer, fraction] = String(\n\t\ttypeof parsedNumber === 'string' && !isHexStrict(parsedNumber)\n\t\t\t? parsedNumber\n\t\t\t: toNumber(parsedNumber),\n\t)\n\t\t.split('.')\n\t\t.concat('');\n\n\t// join the value removing `.` from\n\t// 24.56 -> 2456\n\tconst value = BigInt(`${integer}${fraction}`);\n\n\t// multiply value with denomination\n\t// 2456 * 1000000 -> 2456000000\n\tconst updatedValue = value * denomination;\n\n\t// check if whole number was passed in\n\tconst decimals = fraction.length;\n\tif (decimals === 0) {\n\t\treturn updatedValue.toString();\n\t}\n\n\t// trim the value to remove extra zeros\n\treturn updatedValue.toString().slice(0, -decimals);\n};\n\n/**\n * Will convert an upper or lowercase Ethereum address to a checksum address.\n * @param address - An address string\n * @returns\tThe checksum address\n * @example\n * ```ts\n * web3.utils.toChecksumAddress('0xc1912fee45d61c87cc5ea59dae31190fffff232d');\n * > \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\"\n * ```\n */\nexport const toChecksumAddress = (address: Address): string => {\n\tif (!isAddress(address, false)) {\n\t\tthrow new InvalidAddressError(address);\n\t}\n\n\tconst lowerCaseAddress = address.toLowerCase().replace(/^0x/i, '');\n\n\t// calling `Uint8Array.from` because `noble-hashes` checks with `instanceof Uint8Array` that fails in some edge cases:\n\t// \thttps://github.com/paulmillr/noble-hashes/issues/25#issuecomment-1750106284\n\tconst hash = utils.uint8ArrayToHexString(\n\t\tkeccak256(validatorUtils.ensureIfUint8Array(utf8ToBytes(lowerCaseAddress))),\n\t);\n\n\tif (\n\t\tisNullish(hash) ||\n\t\thash === '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n\t)\n\t\treturn ''; // // EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\n\n\tlet checksumAddress = '0x';\n\n\tconst addressHash = hash.replace(/^0x/i, '');\n\n\tfor (let i = 0; i < lowerCaseAddress.length; i += 1) {\n\t\t// If ith character is 8 to f then make it uppercase\n\t\tif (parseInt(addressHash[i], 16) > 7) {\n\t\t\tchecksumAddress += lowerCaseAddress[i].toUpperCase();\n\t\t} else {\n\t\t\tchecksumAddress += lowerCaseAddress[i];\n\t\t}\n\t}\n\treturn checksumAddress;\n};\n\nexport const toBool = (value: boolean | string | number | unknown): boolean => {\n\tif (typeof value === 'boolean') {\n\t\treturn value;\n\t}\n\n\tif (typeof value === 'number' && (value === 0 || value === 1)) {\n\t\treturn Boolean(value);\n\t}\n\n\tif (typeof value === 'bigint' && (value === BigInt(0) || value === BigInt(1))) {\n\t\treturn Boolean(value);\n\t}\n\n\tif (\n\t\ttypeof value === 'string' &&\n\t\t!isHexStrict(value) &&\n\t\t(value === '1' || value === '0' || value === 'false' || value === 'true')\n\t) {\n\t\tif (value === 'true') {\n\t\t\treturn true;\n\t\t}\n\t\tif (value === 'false') {\n\t\t\treturn false;\n\t\t}\n\t\treturn Boolean(Number(value));\n\t}\n\n\tif (typeof value === 'string' && isHexStrict(value) && (value === '0x1' || value === '0x0')) {\n\t\treturn Boolean(toNumber(value));\n\t}\n\n\tthrow new InvalidBooleanError(value);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}