{"ast":null,"code":"\"use strict\";\n\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create2ContractAddress = exports.createContractAddress = exports.getCreateAccessListParams = exports.isWeb3ContractContext = exports.getEstimateGasParams = exports.getEthTxCallParams = exports.getSendTxParams = void 0;\nconst rlp_1 = require(\"@ethereumjs/rlp\");\nconst web3_errors_1 = require(\"web3-errors\");\nconst web3_utils_1 = require(\"web3-utils\");\nconst web3_validator_1 = require(\"web3-validator\");\nconst encoding_js_1 = require(\"./encoding.js\");\nconst dataInputEncodeMethodHelper = (txParams, abi, params, dataInputFill) => {\n  var _a, _b;\n  const tx = {};\n  if (!(0, web3_utils_1.isNullish)(txParams.data) || dataInputFill === 'both') {\n    tx.data = (0, encoding_js_1.encodeMethodABI)(abi, params, (_a = txParams.data) !== null && _a !== void 0 ? _a : txParams.input);\n  }\n  if (!(0, web3_utils_1.isNullish)(txParams.input) || dataInputFill === 'both') {\n    tx.input = (0, encoding_js_1.encodeMethodABI)(abi, params, (_b = txParams.input) !== null && _b !== void 0 ? _b : txParams.data);\n  }\n  // if input and data is empty, use web3config default\n  if ((0, web3_utils_1.isNullish)(tx.input) && (0, web3_utils_1.isNullish)(tx.data)) {\n    tx[dataInputFill] = (0, encoding_js_1.encodeMethodABI)(abi, params);\n  }\n  return {\n    data: tx.data,\n    input: tx.input\n  };\n};\nconst getSendTxParams = ({\n  abi,\n  params,\n  options,\n  contractOptions\n}) => {\n  var _a, _b, _c;\n  const deploymentCall = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.input) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : contractOptions.input) !== null && _c !== void 0 ? _c : contractOptions.data;\n  if (!deploymentCall && !(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {\n    throw new web3_errors_1.Web3ContractError('Contract address not specified');\n  }\n  if (!(options === null || options === void 0 ? void 0 : options.from) && !contractOptions.from) {\n    throw new web3_errors_1.Web3ContractError('Contract \"from\" address not specified');\n  }\n  let txParams = (0, web3_utils_1.mergeDeep)({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n    maxFeePerGas: contractOptions.maxFeePerGas,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\nexports.getSendTxParams = getSendTxParams;\nconst getEthTxCallParams = ({\n  abi,\n  params,\n  options,\n  contractOptions\n}) => {\n  if (!(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {\n    throw new web3_errors_1.Web3ContractError('Contract address not specified');\n  }\n  let txParams = (0, web3_utils_1.mergeDeep)({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n    maxFeePerGas: contractOptions.maxFeePerGas,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\nexports.getEthTxCallParams = getEthTxCallParams;\nconst getEstimateGasParams = ({\n  abi,\n  params,\n  options,\n  contractOptions\n}) => {\n  let txParams = (0, web3_utils_1.mergeDeep)({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\nexports.getEstimateGasParams = getEstimateGasParams;\nconst isWeb3ContractContext = options => typeof options === 'object' && !(0, web3_utils_1.isNullish)(options) && Object.keys(options).length !== 0 && !(0, web3_utils_1.isContractInitOptions)(options);\nexports.isWeb3ContractContext = isWeb3ContractContext;\nconst getCreateAccessListParams = ({\n  abi,\n  params,\n  options,\n  contractOptions\n}) => {\n  if (!(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {\n    throw new web3_errors_1.Web3ContractError('Contract address not specified');\n  }\n  if (!(options === null || options === void 0 ? void 0 : options.from) && !contractOptions.from) {\n    throw new web3_errors_1.Web3ContractError('Contract \"from\" address not specified');\n  }\n  let txParams = (0, web3_utils_1.mergeDeep)({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n    maxFeePerGas: contractOptions.maxFeePerGas,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\nexports.getCreateAccessListParams = getCreateAccessListParams;\nconst createContractAddress = (from, nonce) => {\n  if (!(0, web3_validator_1.isAddress)(from)) throw new web3_errors_1.InvalidAddressError(`Invalid address given ${from}`);\n  let nonceValue = nonce;\n  if (typeof nonce === 'string' && (0, web3_validator_1.isHexString)(nonce)) nonceValue = (0, web3_utils_1.hexToNumber)(nonce);else if (typeof nonce === 'string' && !(0, web3_validator_1.isHexString)(nonce)) throw new web3_errors_1.InvalidNumberError('Invalid nonce value format');\n  const rlpEncoded = rlp_1.RLP.encode([from, nonceValue]);\n  const result = (0, web3_utils_1.keccak256)(rlpEncoded);\n  const contractAddress = '0x'.concat(result.substring(26));\n  return (0, web3_utils_1.toChecksumAddress)(contractAddress);\n};\nexports.createContractAddress = createContractAddress;\nconst create2ContractAddress = (from, salt, initCode) => {\n  if (!(0, web3_validator_1.isAddress)(from)) throw new web3_errors_1.InvalidAddressError(`Invalid address given ${from}`);\n  if (!(0, web3_validator_1.isHexString)(salt)) throw new web3_errors_1.InvalidMethodParamsError(`Invalid salt value ${salt}`);\n  if (!(0, web3_validator_1.isHexString)(initCode)) throw new web3_errors_1.InvalidMethodParamsError(`Invalid initCode value ${initCode}`);\n  const initCodeHash = (0, web3_utils_1.keccak256)(initCode);\n  const initCodeHashPadded = initCodeHash.padStart(64, '0'); // Pad to 32 bytes (64 hex characters)\n  const create2Params = ['0xff', from, salt, initCodeHashPadded].map(x => x.replace(/0x/, ''));\n  const create2Address = `0x${create2Params.join('')}`;\n  return (0, web3_utils_1.toChecksumAddress)(`0x${(0, web3_utils_1.keccak256)(create2Address).slice(26)}`); // Slice to get the last 20 bytes (40 hex characters) & checksum\n};\nexports.create2ContractAddress = create2ContractAddress;","map":{"version":3,"names":["rlp_1","require","web3_errors_1","web3_utils_1","web3_validator_1","encoding_js_1","dataInputEncodeMethodHelper","txParams","abi","params","dataInputFill","tx","isNullish","data","encodeMethodABI","_a","input","_b","getSendTxParams","options","contractOptions","deploymentCall","_c","to","address","Web3ContractError","from","mergeDeep","gas","gasPrice","maxPriorityFeePerGas","maxFeePerGas","dataInput","Object","assign","exports","getEthTxCallParams","getEstimateGasParams","isWeb3ContractContext","keys","length","isContractInitOptions","getCreateAccessListParams","createContractAddress","nonce","isAddress","InvalidAddressError","nonceValue","isHexString","hexToNumber","InvalidNumberError","rlpEncoded","RLP","encode","result","keccak256","contractAddress","concat","substring","toChecksumAddress","create2ContractAddress","salt","initCode","InvalidMethodParamsError","initCodeHash","initCodeHashPadded","padStart","create2Params","map","x","replace","create2Address","join","slice"],"sources":["/home/nathan/node_modules/web3-eth-contract/src/utils.ts"],"sourcesContent":["ï»¿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { RLP } from '@ethereumjs/rlp';\nimport {\n\tInvalidAddressError,\n\tInvalidMethodParamsError,\n\tInvalidNumberError,\n\tWeb3ContractError,\n} from 'web3-errors';\nimport {\n\tTransactionForAccessList,\n\tAbiFunctionFragment,\n\tTransactionWithSenderAPI,\n\tTransactionCall,\n\tHexString,\n\tAddress,\n\tNonPayableCallOptions,\n\tPayableCallOptions,\n\tContractOptions,\n\tNumbers,\n\tAbiConstructorFragment,\n} from 'web3-types';\nimport {\n\tisNullish,\n\tmergeDeep,\n\tisContractInitOptions,\n\tkeccak256,\n\ttoChecksumAddress,\n\thexToNumber,\n} from 'web3-utils';\nimport { isAddress, isHexString } from 'web3-validator';\nimport { encodeMethodABI } from './encoding.js';\nimport { Web3ContractContext } from './types.js';\n\nconst dataInputEncodeMethodHelper = (\n\ttxParams: TransactionCall | TransactionForAccessList,\n\tabi: AbiFunctionFragment | AbiConstructorFragment,\n\tparams: unknown[],\n\tdataInputFill?: 'data' | 'input' | 'both',\n): { data?: HexString; input?: HexString } => {\n\tconst tx: { data?: HexString; input?: HexString } = {};\n\tif (!isNullish(txParams.data) || dataInputFill === 'both') {\n\t\ttx.data = encodeMethodABI(abi, params, (txParams.data ?? txParams.input) as HexString);\n\t}\n\tif (!isNullish(txParams.input) || dataInputFill === 'both') {\n\t\ttx.input = encodeMethodABI(abi, params, (txParams.input ?? txParams.data) as HexString);\n\t}\n\t// if input and data is empty, use web3config default\n\tif (isNullish(tx.input) && isNullish(tx.data)) {\n\t\ttx[dataInputFill as 'data' | 'input'] = encodeMethodABI(abi, params);\n\t}\n\treturn { data: tx.data as HexString, input: tx.input as HexString };\n};\n\nexport const getSendTxParams = ({\n\tabi,\n\tparams,\n\toptions,\n\tcontractOptions,\n}: {\n\tabi: AbiFunctionFragment | AbiConstructorFragment;\n\tparams: unknown[];\n\toptions?: (PayableCallOptions | NonPayableCallOptions) & {\n\t\tinput?: HexString;\n\t\tdata?: HexString;\n\t\tto?: Address;\n\t\tdataInputFill?: 'input' | 'data' | 'both';\n\t};\n\tcontractOptions: ContractOptions;\n}): TransactionCall => {\n\tconst deploymentCall =\n\t\toptions?.input ?? options?.data ?? contractOptions.input ?? contractOptions.data;\n\tif (!deploymentCall && !options?.to && !contractOptions.address) {\n\t\tthrow new Web3ContractError('Contract address not specified');\n\t}\n\n\tif (!options?.from && !contractOptions.from) {\n\t\tthrow new Web3ContractError('Contract \"from\" address not specified');\n\t}\n\tlet txParams = mergeDeep(\n\t\t{\n\t\t\tto: contractOptions.address,\n\t\t\tgas: contractOptions.gas,\n\t\t\tgasPrice: contractOptions.gasPrice,\n\t\t\tfrom: contractOptions.from,\n\t\t\tinput: contractOptions.input,\n\t\t\tmaxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n\t\t\tmaxFeePerGas: contractOptions.maxFeePerGas,\n\t\t\tdata: contractOptions.data,\n\t\t},\n\t\toptions as unknown as Record<string, unknown>,\n\t) as unknown as TransactionCall;\n\tconst dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options?.dataInputFill);\n\ttxParams = { ...txParams, data: dataInput.data, input: dataInput.input };\n\n\treturn txParams;\n};\n\nexport const getEthTxCallParams = ({\n\tabi,\n\tparams,\n\toptions,\n\tcontractOptions,\n}: {\n\tabi: AbiFunctionFragment;\n\tparams: unknown[];\n\toptions?: (PayableCallOptions | NonPayableCallOptions) & {\n\t\tto?: Address;\n\t\tdataInputFill?: 'input' | 'data' | 'both';\n\t};\n\tcontractOptions: ContractOptions;\n}): TransactionCall => {\n\tif (!options?.to && !contractOptions.address) {\n\t\tthrow new Web3ContractError('Contract address not specified');\n\t}\n\tlet txParams = mergeDeep(\n\t\t{\n\t\t\tto: contractOptions.address,\n\t\t\tgas: contractOptions.gas,\n\t\t\tgasPrice: contractOptions.gasPrice,\n\t\t\tfrom: contractOptions.from,\n\t\t\tinput: contractOptions.input,\n\t\t\tmaxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n\t\t\tmaxFeePerGas: contractOptions.maxFeePerGas,\n\t\t\tdata: contractOptions.data,\n\t\t},\n\t\toptions as unknown as Record<string, unknown>,\n\t) as unknown as TransactionCall;\n\n\tconst dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options?.dataInputFill);\n\ttxParams = { ...txParams, data: dataInput.data, input: dataInput.input };\n\n\treturn txParams;\n};\n\nexport const getEstimateGasParams = ({\n\tabi,\n\tparams,\n\toptions,\n\tcontractOptions,\n}: {\n\tabi: AbiFunctionFragment;\n\tparams: unknown[];\n\toptions?: (PayableCallOptions | NonPayableCallOptions) & {\n\t\tdataInputFill?: 'input' | 'data' | 'both';\n\t};\n\tcontractOptions: ContractOptions;\n}): Partial<TransactionWithSenderAPI> => {\n\tlet txParams = mergeDeep(\n\t\t{\n\t\t\tto: contractOptions.address,\n\t\t\tgas: contractOptions.gas,\n\t\t\tgasPrice: contractOptions.gasPrice,\n\t\t\tfrom: contractOptions.from,\n\t\t\tinput: contractOptions.input,\n\t\t\tdata: contractOptions.data,\n\t\t},\n\t\toptions as unknown as Record<string, unknown>,\n\t) as unknown as TransactionCall;\n\n\tconst dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options?.dataInputFill);\n\ttxParams = { ...txParams, data: dataInput.data, input: dataInput.input };\n\n\treturn txParams as TransactionWithSenderAPI;\n};\n\nexport const isWeb3ContractContext = (options: unknown): options is Web3ContractContext =>\n\ttypeof options === 'object' &&\n\t!isNullish(options) &&\n\tObject.keys(options).length !== 0 &&\n\t!isContractInitOptions(options);\n\nexport const getCreateAccessListParams = ({\n\tabi,\n\tparams,\n\toptions,\n\tcontractOptions,\n}: {\n\tabi: AbiFunctionFragment;\n\tparams: unknown[];\n\toptions?: (PayableCallOptions | NonPayableCallOptions) & {\n\t\tto?: Address;\n\t\tdataInputFill?: 'input' | 'data' | 'both';\n\t};\n\tcontractOptions: ContractOptions;\n}): TransactionForAccessList => {\n\tif (!options?.to && !contractOptions.address) {\n\t\tthrow new Web3ContractError('Contract address not specified');\n\t}\n\n\tif (!options?.from && !contractOptions.from) {\n\t\tthrow new Web3ContractError('Contract \"from\" address not specified');\n\t}\n\n\tlet txParams = mergeDeep(\n\t\t{\n\t\t\tto: contractOptions.address,\n\t\t\tgas: contractOptions.gas,\n\t\t\tgasPrice: contractOptions.gasPrice,\n\t\t\tfrom: contractOptions.from,\n\t\t\tinput: contractOptions.input,\n\t\t\tmaxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n\t\t\tmaxFeePerGas: contractOptions.maxFeePerGas,\n\t\t\tdata: contractOptions.data,\n\t\t},\n\t\toptions as unknown as Record<string, unknown>,\n\t) as unknown as TransactionForAccessList;\n\n\tconst dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options?.dataInputFill);\n\ttxParams = { ...txParams, data: dataInput.data, input: dataInput.input };\n\n\treturn txParams;\n};\n\nexport const createContractAddress = (from: Address, nonce: Numbers): Address => {\n\tif (!isAddress(from)) throw new InvalidAddressError(`Invalid address given ${from}`);\n\n\tlet nonceValue = nonce;\n\tif (typeof nonce === 'string' && isHexString(nonce)) nonceValue = hexToNumber(nonce);\n\telse if (typeof nonce === 'string' && !isHexString(nonce))\n\t\tthrow new InvalidNumberError('Invalid nonce value format');\n\n\tconst rlpEncoded = RLP.encode([from, nonceValue]);\n\tconst result = keccak256(rlpEncoded);\n\n\tconst contractAddress = '0x'.concat(result.substring(26));\n\n\treturn toChecksumAddress(contractAddress);\n};\n\nexport const create2ContractAddress = (\n\tfrom: Address,\n\tsalt: HexString,\n\tinitCode: HexString,\n): Address => {\n\tif (!isAddress(from)) throw new InvalidAddressError(`Invalid address given ${from}`);\n\n\tif (!isHexString(salt)) throw new InvalidMethodParamsError(`Invalid salt value ${salt}`);\n\n\tif (!isHexString(initCode))\n\t\tthrow new InvalidMethodParamsError(`Invalid initCode value ${initCode}`);\n\n\tconst initCodeHash = keccak256(initCode);\n\tconst initCodeHashPadded = initCodeHash.padStart(64, '0'); // Pad to 32 bytes (64 hex characters)\n\tconst create2Params = ['0xff', from, salt, initCodeHashPadded].map(x => x.replace(/0x/, ''));\n\tconst create2Address = `0x${create2Params.join('')}`;\n\n\treturn toChecksumAddress(`0x${keccak256(create2Address).slice(26)}`); // Slice to get the last 20 bytes (40 hex characters) & checksum\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}