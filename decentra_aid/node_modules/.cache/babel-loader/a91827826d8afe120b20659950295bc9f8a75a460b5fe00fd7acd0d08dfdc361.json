{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBytes = encodeBytes;\nexports.decodeBytes = decodeBytes;\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nconst web3_errors_1 = require(\"web3-errors\");\nconst web3_utils_1 = require(\"web3-utils\");\nconst web3_validator_1 = require(\"web3-validator\");\nconst utils_js_1 = require(\"../utils.js\");\nconst number_js_1 = require(\"./number.js\");\nconst MAX_STATIC_BYTES_COUNT = 32;\nfunction encodeBytes(param, input) {\n  // hack for odd length hex strings\n  if (typeof input === 'string' && input.length % 2 !== 0) {\n    // eslint-disable-next-line no-param-reassign\n    input += '0';\n  }\n  if (!(0, web3_validator_1.isBytes)(input)) {\n    throw new web3_errors_1.AbiError('provided input is not valid bytes value', {\n      type: param.type,\n      value: input,\n      name: param.name\n    });\n  }\n  const bytes = (0, web3_utils_1.bytesToUint8Array)(input);\n  const [, size] = param.type.split('bytes');\n  // fixed size\n  if (size) {\n    if (Number(size) > MAX_STATIC_BYTES_COUNT || Number(size) < 1) {\n      throw new web3_errors_1.AbiError('invalid bytes type. Static byte type can have between 1 and 32 bytes', {\n        type: param.type\n      });\n    }\n    if (Number(size) < bytes.length) {\n      throw new web3_errors_1.AbiError('provided input size is different than type size', {\n        type: param.type,\n        value: input,\n        name: param.name\n      });\n    }\n    const encoded = (0, utils_js_1.alloc)(utils_js_1.WORD_SIZE);\n    encoded.set(bytes);\n    return {\n      dynamic: false,\n      encoded\n    };\n  }\n  const partsLength = Math.ceil(bytes.length / utils_js_1.WORD_SIZE);\n  // one word for length of data + WORD for each part of actual data\n  const encoded = (0, utils_js_1.alloc)(utils_js_1.WORD_SIZE + partsLength * utils_js_1.WORD_SIZE);\n  encoded.set((0, number_js_1.encodeNumber)({\n    type: 'uint32',\n    name: ''\n  }, bytes.length).encoded);\n  encoded.set(bytes, utils_js_1.WORD_SIZE);\n  return {\n    dynamic: true,\n    encoded\n  };\n}\nfunction decodeBytes(param, bytes) {\n  const [, sizeString] = param.type.split('bytes');\n  let size = Number(sizeString);\n  let remainingBytes = bytes;\n  let partsCount = 1;\n  let consumed = 0;\n  if (!size) {\n    // dynamic bytes\n    const result = (0, number_js_1.decodeNumber)({\n      type: 'uint32',\n      name: ''\n    }, remainingBytes);\n    size = Number(result.result);\n    consumed += result.consumed;\n    remainingBytes = result.encoded;\n    partsCount = Math.ceil(size / utils_js_1.WORD_SIZE);\n  }\n  if (size > bytes.length) {\n    throw new web3_errors_1.AbiError('there is not enough data to decode', {\n      type: param.type,\n      encoded: bytes,\n      size\n    });\n  }\n  return {\n    result: (0, web3_utils_1.bytesToHex)(remainingBytes.subarray(0, size)),\n    encoded: remainingBytes.subarray(partsCount * utils_js_1.WORD_SIZE),\n    consumed: consumed + partsCount * utils_js_1.WORD_SIZE\n  };\n}","map":{"version":3,"names":["exports","encodeBytes","decodeBytes","web3_errors_1","require","web3_utils_1","web3_validator_1","utils_js_1","number_js_1","MAX_STATIC_BYTES_COUNT","param","input","length","isBytes","AbiError","type","value","name","bytes","bytesToUint8Array","size","split","Number","encoded","alloc","WORD_SIZE","set","dynamic","partsLength","Math","ceil","encodeNumber","sizeString","remainingBytes","partsCount","consumed","result","decodeNumber","bytesToHex","subarray"],"sources":["/home/ubuntu/node_modules/web3-eth-abi/src/coders/base/bytes.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { AbiParameter, Bytes } from 'web3-types';\nimport { bytesToHex, bytesToUint8Array } from 'web3-utils';\nimport { isBytes, ValidInputTypes } from 'web3-validator';\nimport { DecoderResult, EncoderResult } from '../types.js';\nimport { alloc, WORD_SIZE } from '../utils.js';\nimport { decodeNumber, encodeNumber } from './number.js';\n\nconst MAX_STATIC_BYTES_COUNT = 32;\n\nexport function encodeBytes(param: AbiParameter, input: unknown): EncoderResult {\n\t// hack for odd length hex strings\n\tif (typeof input === 'string' && input.length % 2 !== 0) {\n\t\t// eslint-disable-next-line no-param-reassign\n\t\tinput += '0';\n\t}\n\tif (!isBytes(input as ValidInputTypes)) {\n\t\tthrow new AbiError('provided input is not valid bytes value', {\n\t\t\ttype: param.type,\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t});\n\t}\n\tconst bytes = bytesToUint8Array(input as Bytes);\n\tconst [, size] = param.type.split('bytes');\n\t// fixed size\n\tif (size) {\n\t\tif (Number(size) > MAX_STATIC_BYTES_COUNT || Number(size) < 1) {\n\t\t\tthrow new AbiError(\n\t\t\t\t'invalid bytes type. Static byte type can have between 1 and 32 bytes',\n\t\t\t\t{\n\t\t\t\t\ttype: param.type,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t\tif (Number(size) < bytes.length) {\n\t\t\tthrow new AbiError('provided input size is different than type size', {\n\t\t\t\ttype: param.type,\n\t\t\t\tvalue: input,\n\t\t\t\tname: param.name,\n\t\t\t});\n\t\t}\n\t\tconst encoded = alloc(WORD_SIZE);\n\t\tencoded.set(bytes);\n\t\treturn {\n\t\t\tdynamic: false,\n\t\t\tencoded,\n\t\t};\n\t}\n\n\tconst partsLength = Math.ceil(bytes.length / WORD_SIZE);\n\t// one word for length of data + WORD for each part of actual data\n\tconst encoded = alloc(WORD_SIZE + partsLength * WORD_SIZE);\n\n\tencoded.set(encodeNumber({ type: 'uint32', name: '' }, bytes.length).encoded);\n\tencoded.set(bytes, WORD_SIZE);\n\treturn {\n\t\tdynamic: true,\n\t\tencoded,\n\t};\n}\n\nexport function decodeBytes(param: AbiParameter, bytes: Uint8Array): DecoderResult<string> {\n\tconst [, sizeString] = param.type.split('bytes');\n\tlet size = Number(sizeString);\n\tlet remainingBytes = bytes;\n\tlet partsCount = 1;\n\tlet consumed = 0;\n\tif (!size) {\n\t\t// dynamic bytes\n\t\tconst result = decodeNumber({ type: 'uint32', name: '' }, remainingBytes);\n\t\tsize = Number(result.result);\n\t\tconsumed += result.consumed;\n\t\tremainingBytes = result.encoded;\n\t\tpartsCount = Math.ceil(size / WORD_SIZE);\n\t}\n\tif (size > bytes.length) {\n\t\tthrow new AbiError('there is not enough data to decode', {\n\t\t\ttype: param.type,\n\t\t\tencoded: bytes,\n\t\t\tsize,\n\t\t});\n\t}\n\n\treturn {\n\t\tresult: bytesToHex(remainingBytes.subarray(0, size)),\n\t\tencoded: remainingBytes.subarray(partsCount * WORD_SIZE),\n\t\tconsumed: consumed + partsCount * WORD_SIZE,\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}