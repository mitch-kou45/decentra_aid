{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.format = exports.convert = exports.convertScalarValue = exports.isDataFormat = void 0;\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nconst web3_errors_1 = require(\"web3-errors\");\nconst web3_types_1 = require(\"web3-types\");\nconst web3_validator_1 = require(\"web3-validator\");\nconst converters_js_1 = require(\"./converters.js\");\nconst objects_js_1 = require(\"./objects.js\");\nconst string_manipulation_js_1 = require(\"./string_manipulation.js\");\nconst uint8array_js_1 = require(\"./uint8array.js\");\nconst {\n  parseBaseType\n} = web3_validator_1.utils;\nconst isDataFormat = dataFormat => typeof dataFormat === 'object' && !(0, web3_validator_1.isNullish)(dataFormat) && 'number' in dataFormat && 'bytes' in dataFormat;\nexports.isDataFormat = isDataFormat;\n/**\n * Finds the schema that corresponds to a specific data path within a larger JSON schema.\n * It works by iterating over the dataPath array and traversing the JSON schema one step at a time until it reaches the end of the path.\n *\n * @param schema - represents a JSON schema, which is an object that describes the structure of JSON data\n * @param dataPath - represents an array of strings that specifies the path to the data within the JSON schema\n * @param oneOfPath - represents an optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns the JSON schema that matches the data path\n *\n */\nconst findSchemaByDataPath = (schema, dataPath, oneOfPath = []) => {\n  let result = Object.assign({}, schema);\n  let previousDataPath;\n  for (const dataPart of dataPath) {\n    if (result.oneOf && previousDataPath) {\n      const currentDataPath = previousDataPath;\n      const path = oneOfPath.find(([key]) => key === currentDataPath);\n      if (path && path[0] === previousDataPath) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        result = result.oneOf[path[1]];\n      }\n    }\n    if (!result.properties && !result.items) {\n      return undefined;\n    }\n    if (result.properties) {\n      result = result.properties[dataPart];\n    } else if (result.items && result.items.properties) {\n      const node = result.items.properties;\n      result = node[dataPart];\n    } else if (result.items && (0, web3_validator_1.isObject)(result.items)) {\n      result = result.items;\n    } else if (result.items && Array.isArray(result.items)) {\n      result = result.items[parseInt(dataPart, 10)];\n    }\n    if (result && dataPart) previousDataPath = dataPart;\n  }\n  return result;\n};\n/**\n * Converts a value depending on the format\n * @param value - value to convert\n * @param ethType - The type of the value to be parsed\n * @param format - The format to be converted to\n * @returns - The value converted to the specified format\n */\nconst convertScalarValue = (value, ethType, format) => {\n  try {\n    const {\n      baseType,\n      baseTypeSize\n    } = parseBaseType(ethType);\n    if (baseType === 'int' || baseType === 'uint') {\n      switch (format.number) {\n        case web3_types_1.FMT_NUMBER.NUMBER:\n          return Number((0, converters_js_1.toBigInt)(value));\n        case web3_types_1.FMT_NUMBER.HEX:\n          return (0, converters_js_1.numberToHex)((0, converters_js_1.toBigInt)(value));\n        case web3_types_1.FMT_NUMBER.STR:\n          return (0, converters_js_1.toBigInt)(value).toString();\n        case web3_types_1.FMT_NUMBER.BIGINT:\n          return (0, converters_js_1.toBigInt)(value);\n        default:\n          throw new web3_errors_1.FormatterError(`Invalid format: ${String(format.number)}`);\n      }\n    }\n    if (baseType === 'bytes') {\n      let paddedValue;\n      if (baseTypeSize) {\n        if (typeof value === 'string') paddedValue = (0, string_manipulation_js_1.padLeft)(value, baseTypeSize * 2);else if ((0, uint8array_js_1.isUint8Array)(value)) {\n          paddedValue = (0, uint8array_js_1.uint8ArrayConcat)(new Uint8Array(baseTypeSize - value.length), value);\n        }\n      } else {\n        paddedValue = value;\n      }\n      switch (format.bytes) {\n        case web3_types_1.FMT_BYTES.HEX:\n          return (0, converters_js_1.bytesToHex)((0, converters_js_1.bytesToUint8Array)(paddedValue));\n        case web3_types_1.FMT_BYTES.UINT8ARRAY:\n          return (0, converters_js_1.bytesToUint8Array)(paddedValue);\n        default:\n          throw new web3_errors_1.FormatterError(`Invalid format: ${String(format.bytes)}`);\n      }\n    }\n    if (baseType === 'string') {\n      return String(value);\n    }\n  } catch (error) {\n    // If someone didn't use `eth` keyword we can return original value\n    // as the scope of this code is formatting not validation\n    return value;\n  }\n  return value;\n};\nexports.convertScalarValue = convertScalarValue;\nconst convertArray = ({\n  value,\n  schemaProp,\n  schema,\n  object,\n  key,\n  dataPath,\n  format,\n  oneOfPath = []\n}) => {\n  var _a, _b;\n  // If value is an array\n  if (Array.isArray(value)) {\n    let _schemaProp = schemaProp;\n    // TODO This is a naive approach to solving the issue of\n    // a schema using oneOf. This chunk of code was intended to handle\n    // BlockSchema.transactions\n    // TODO BlockSchema.transactions are not being formatted\n    if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== undefined) {\n      // The following code is basically saying:\n      // if the schema specifies oneOf, then we are to loop\n      // over each possible schema and check if they type of the schema\n      // matches the type of value[0], and if so we use the oneOfSchemaProp\n      // as the schema for formatting\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {\n        var _a, _b;\n        if (!Array.isArray(schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) && (typeof value[0] === 'object' && ((_a = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _a === void 0 ? void 0 : _a.type) === 'object' || typeof value[0] === 'string' && ((_b = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _b === void 0 ? void 0 : _b.type) !== 'object')) {\n          _schemaProp = oneOfSchemaProp;\n          oneOfPath.push([key, index]);\n        }\n      });\n    }\n    if ((0, web3_validator_1.isNullish)(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n      // Can not find schema for array item, delete that item\n      // eslint-disable-next-line no-param-reassign\n      delete object[key];\n      dataPath.pop();\n      return true;\n    }\n    // If schema for array items is a single type\n    if ((0, web3_validator_1.isObject)(_schemaProp.items) && !(0, web3_validator_1.isNullish)(_schemaProp.items.format)) {\n      for (let i = 0; i < value.length; i += 1) {\n        // eslint-disable-next-line no-param-reassign\n        object[key][i] = (0, exports.convertScalarValue)(value[i],\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        (_a = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _a === void 0 ? void 0 : _a.format, format);\n      }\n      dataPath.pop();\n      return true;\n    }\n    // If schema for array items is an object\n    if (!Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _b === void 0 ? void 0 : _b.type) === 'object') {\n      for (const arrObject of value) {\n        // eslint-disable-next-line no-use-before-define\n        (0, exports.convert)(arrObject, schema, dataPath, format, oneOfPath);\n      }\n      dataPath.pop();\n      return true;\n    }\n    // If schema for array is a tuple\n    if (Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n      for (let i = 0; i < value.length; i += 1) {\n        // eslint-disable-next-line no-param-reassign\n        object[key][i] = (0, exports.convertScalarValue)(value[i], _schemaProp.items[i].format, format);\n      }\n      dataPath.pop();\n      return true;\n    }\n  }\n  return false;\n};\n/**\n * Converts the data to the specified format\n * @param data - data to convert\n * @param schema - The JSON schema that describes the structure of the data\n * @param dataPath - A string array that specifies the path to the data within the JSON schema\n * @param format  - The format to be converted to\n * @param oneOfPath - An optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns - The data converted to the specified format\n */\nconst convert = (data, schema, dataPath, format, oneOfPath = []) => {\n  var _a;\n  // If it's a scalar value\n  if (!(0, web3_validator_1.isObject)(data) && !Array.isArray(data)) {\n    return (0, exports.convertScalarValue)(data, schema === null || schema === void 0 ? void 0 : schema.format, format);\n  }\n  const object = data;\n  // case when schema is array and `items` is object\n  if (Array.isArray(object) && (schema === null || schema === void 0 ? void 0 : schema.type) === 'array' && ((_a = schema === null || schema === void 0 ? void 0 : schema.items) === null || _a === void 0 ? void 0 : _a.type) === 'object') {\n    convertArray({\n      value: object,\n      schemaProp: schema,\n      schema,\n      object,\n      key: '',\n      dataPath,\n      format,\n      oneOfPath\n    });\n  } else {\n    for (const [key, value] of Object.entries(object)) {\n      dataPath.push(key);\n      let schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);\n      // If value is a scaler value\n      if ((0, web3_validator_1.isNullish)(schemaProp)) {\n        delete object[key];\n        dataPath.pop();\n        continue;\n      }\n      // If value is an object, recurse into it\n      if ((0, web3_validator_1.isObject)(value)) {\n        (0, exports.convert)(value, schema, dataPath, format, oneOfPath);\n        dataPath.pop();\n        continue;\n      }\n      // If value is an array\n      if (convertArray({\n        value,\n        schemaProp,\n        schema,\n        object,\n        key,\n        dataPath,\n        format,\n        oneOfPath\n      })) {\n        continue;\n      }\n      // The following code is basically saying:\n      // if the schema specifies oneOf, then we are to loop\n      // over each possible schema and check if they type of the schema specifies format\n      // and if so we use the oneOfSchemaProp as the schema for formatting\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.format) === undefined && (schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== undefined) {\n        for (const [_index, oneOfSchemaProp] of schemaProp.oneOf.entries()) {\n          if ((oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.format) !== undefined) {\n            schemaProp = oneOfSchemaProp;\n            break;\n          }\n        }\n      }\n      object[key] = (0, exports.convertScalarValue)(value, schemaProp.format, format);\n      dataPath.pop();\n    }\n  }\n  return object;\n};\nexports.convert = convert;\n/**\n * Given data that can be interpreted according to the provided schema, returns equivalent data that has been formatted\n * according to the provided return format.\n *\n * @param schema - how to interpret the data\n * @param data - data to be formatted\n * @param returnFormat - how to format the data\n * @returns - formatted data\n *\n * @example\n *\n * ```js\n * import { FMT_NUMBER, utils } from \"web3\";\n *\n * console.log(\n *   utils.format({ format: \"uint\" }, \"221\", { number: FMT_NUMBER.HEX }),\n * );\n * // 0xdd\n * ```\n *\n */\nconst format = (schema, data, returnFormat = web3_types_1.DEFAULT_RETURN_FORMAT) => {\n  let dataToParse;\n  if ((0, web3_validator_1.isObject)(data)) {\n    dataToParse = (0, objects_js_1.mergeDeep)({}, data);\n  } else if (Array.isArray(data)) {\n    dataToParse = [...data];\n  } else {\n    dataToParse = data;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const jsonSchema = (0, web3_validator_1.isObject)(schema) ? schema : web3_validator_1.utils.ethAbiToJsonSchema(schema);\n  if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {\n    throw new web3_errors_1.FormatterError('Invalid json schema for formatting');\n  }\n  return (0, exports.convert)(dataToParse, jsonSchema, [], returnFormat);\n};\nexports.format = format;","map":{"version":3,"names":["web3_errors_1","require","web3_types_1","web3_validator_1","converters_js_1","objects_js_1","string_manipulation_js_1","uint8array_js_1","parseBaseType","utils","isDataFormat","dataFormat","isNullish","exports","findSchemaByDataPath","schema","dataPath","oneOfPath","result","Object","assign","previousDataPath","dataPart","oneOf","currentDataPath","path","find","key","properties","items","undefined","node","isObject","Array","isArray","parseInt","convertScalarValue","value","ethType","format","baseType","baseTypeSize","number","FMT_NUMBER","NUMBER","Number","toBigInt","HEX","numberToHex","STR","toString","BIGINT","FormatterError","String","paddedValue","padLeft","isUint8Array","uint8ArrayConcat","Uint8Array","length","bytes","FMT_BYTES","bytesToHex","bytesToUint8Array","UINT8ARRAY","error","convertArray","schemaProp","object","_schemaProp","forEach","oneOfSchemaProp","index","_a","type","_b","push","pop","i","arrObject","convert","data","entries","_index","returnFormat","DEFAULT_RETURN_FORMAT","dataToParse","mergeDeep","jsonSchema","ethAbiToJsonSchema"],"sources":["/home/nathan/node_modules/web3-utils/src/formatter.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { FormatterError } from 'web3-errors';\nimport {\n\tBytes,\n\tDataFormat,\n\tFMT_BYTES,\n\tFMT_NUMBER,\n\tFormatType,\n\tDEFAULT_RETURN_FORMAT,\n} from 'web3-types';\nimport { isNullish, isObject, JsonSchema, utils, ValidationSchemaInput } from 'web3-validator';\nimport { bytesToUint8Array, bytesToHex, numberToHex, toBigInt } from './converters.js';\nimport { mergeDeep } from './objects.js';\nimport { padLeft } from './string_manipulation.js';\nimport { isUint8Array, uint8ArrayConcat } from './uint8array.js';\n\nconst { parseBaseType } = utils;\n\nexport const isDataFormat = (dataFormat: unknown): dataFormat is DataFormat =>\n\ttypeof dataFormat === 'object' &&\n\t!isNullish(dataFormat) &&\n\t'number' in dataFormat &&\n\t'bytes' in dataFormat;\n\n/**\n * Finds the schema that corresponds to a specific data path within a larger JSON schema.\n * It works by iterating over the dataPath array and traversing the JSON schema one step at a time until it reaches the end of the path.\n *\n * @param schema - represents a JSON schema, which is an object that describes the structure of JSON data\n * @param dataPath - represents an array of strings that specifies the path to the data within the JSON schema\n * @param oneOfPath - represents an optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns the JSON schema that matches the data path\n *\n */\nconst findSchemaByDataPath = (\n\tschema: JsonSchema,\n\tdataPath: string[],\n\toneOfPath: [string, number][] = [],\n): JsonSchema | undefined => {\n\tlet result: JsonSchema = { ...schema } as JsonSchema;\n\tlet previousDataPath: string | undefined;\n\n\tfor (const dataPart of dataPath) {\n\t\tif (result.oneOf && previousDataPath) {\n\t\t\tconst currentDataPath = previousDataPath;\n\t\t\tconst path = oneOfPath.find(([key]) => key === currentDataPath);\n\t\t\tif (path && path[0] === previousDataPath) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\t\t\tresult = result.oneOf[path[1]];\n\t\t\t}\n\t\t}\n\t\tif (!result.properties && !result.items) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (result.properties) {\n\t\t\tresult = (result.properties as Record<string, JsonSchema>)[dataPart];\n\t\t} else if (result.items && (result.items as JsonSchema).properties) {\n\t\t\tconst node = (result.items as JsonSchema).properties as Record<string, JsonSchema>;\n\n\t\t\tresult = node[dataPart];\n\t\t} else if (result.items && isObject(result.items)) {\n\t\t\tresult = result.items;\n\t\t} else if (result.items && Array.isArray(result.items)) {\n\t\t\tresult = result.items[parseInt(dataPart, 10)];\n\t\t}\n\n\t\tif (result && dataPart) previousDataPath = dataPart;\n\t}\n\n\treturn result;\n};\n/**\n * Converts a value depending on the format\n * @param value - value to convert\n * @param ethType - The type of the value to be parsed\n * @param format - The format to be converted to\n * @returns - The value converted to the specified format\n */\nexport const convertScalarValue = (value: unknown, ethType: string, format: DataFormat) => {\n\ttry {\n\t\tconst { baseType, baseTypeSize } = parseBaseType(ethType);\n\t\tif (baseType === 'int' || baseType === 'uint') {\n\t\t\tswitch (format.number) {\n\t\t\t\tcase FMT_NUMBER.NUMBER:\n\t\t\t\t\treturn Number(toBigInt(value));\n\t\t\t\tcase FMT_NUMBER.HEX:\n\t\t\t\t\treturn numberToHex(toBigInt(value));\n\t\t\t\tcase FMT_NUMBER.STR:\n\t\t\t\t\treturn toBigInt(value).toString();\n\t\t\t\tcase FMT_NUMBER.BIGINT:\n\t\t\t\t\treturn toBigInt(value);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new FormatterError(`Invalid format: ${String(format.number)}`);\n\t\t\t}\n\t\t}\n\t\tif (baseType === 'bytes') {\n\t\t\tlet paddedValue;\n\t\t\tif (baseTypeSize) {\n\t\t\t\tif (typeof value === 'string') paddedValue = padLeft(value, baseTypeSize * 2);\n\t\t\t\telse if (isUint8Array(value)) {\n\t\t\t\t\tpaddedValue = uint8ArrayConcat(\n\t\t\t\t\t\tnew Uint8Array(baseTypeSize - value.length),\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpaddedValue = value;\n\t\t\t}\n\t\t\tswitch (format.bytes) {\n\t\t\t\tcase FMT_BYTES.HEX:\n\t\t\t\t\treturn bytesToHex(bytesToUint8Array(paddedValue as Bytes));\n\t\t\t\tcase FMT_BYTES.UINT8ARRAY:\n\t\t\t\t\treturn bytesToUint8Array(paddedValue as Bytes);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new FormatterError(`Invalid format: ${String(format.bytes)}`);\n\t\t\t}\n\t\t}\n\n\t\tif (baseType === 'string') {\n\t\t\treturn String(value);\n\t\t}\n\t} catch (error) {\n\t\t// If someone didn't use `eth` keyword we can return original value\n\t\t// as the scope of this code is formatting not validation\n\t\treturn value;\n\t}\n\n\treturn value;\n};\n\nconst convertArray = ({\n\tvalue,\n\tschemaProp,\n\tschema,\n\tobject,\n\tkey,\n\tdataPath,\n\tformat,\n\toneOfPath = [],\n}: {\n\tvalue: unknown;\n\tschemaProp: JsonSchema;\n\tschema: JsonSchema;\n\tobject: Record<string, unknown>;\n\tkey: string;\n\tdataPath: string[];\n\tformat: DataFormat;\n\toneOfPath: [string, number][];\n}) => {\n\t// If value is an array\n\tif (Array.isArray(value)) {\n\t\tlet _schemaProp = schemaProp;\n\n\t\t// TODO This is a naive approach to solving the issue of\n\t\t// a schema using oneOf. This chunk of code was intended to handle\n\t\t// BlockSchema.transactions\n\t\t// TODO BlockSchema.transactions are not being formatted\n\t\tif (schemaProp?.oneOf !== undefined) {\n\t\t\t// The following code is basically saying:\n\t\t\t// if the schema specifies oneOf, then we are to loop\n\t\t\t// over each possible schema and check if they type of the schema\n\t\t\t// matches the type of value[0], and if so we use the oneOfSchemaProp\n\t\t\t// as the schema for formatting\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n\t\t\tschemaProp.oneOf.forEach((oneOfSchemaProp: JsonSchema, index: number) => {\n\t\t\t\tif (\n\t\t\t\t\t!Array.isArray(schemaProp?.items) &&\n\t\t\t\t\t((typeof value[0] === 'object' &&\n\t\t\t\t\t\t(oneOfSchemaProp?.items as JsonSchema)?.type === 'object') ||\n\t\t\t\t\t\t(typeof value[0] === 'string' &&\n\t\t\t\t\t\t\t(oneOfSchemaProp?.items as JsonSchema)?.type !== 'object'))\n\t\t\t\t) {\n\t\t\t\t\t_schemaProp = oneOfSchemaProp;\n\t\t\t\t\toneOfPath.push([key, index]);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (isNullish(_schemaProp?.items)) {\n\t\t\t// Can not find schema for array item, delete that item\n\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\tdelete object[key];\n\t\t\tdataPath.pop();\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// If schema for array items is a single type\n\t\tif (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {\n\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\t(object[key] as unknown[])[i] = convertScalarValue(\n\t\t\t\t\tvalue[i],\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\t\t\t_schemaProp?.items?.format,\n\t\t\t\t\tformat,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdataPath.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\t// If schema for array items is an object\n\t\tif (!Array.isArray(_schemaProp?.items) && _schemaProp?.items?.type === 'object') {\n\t\t\tfor (const arrObject of value) {\n\t\t\t\t// eslint-disable-next-line no-use-before-define\n\t\t\t\tconvert(\n\t\t\t\t\tarrObject as Record<string, unknown> | unknown[],\n\t\t\t\t\tschema,\n\t\t\t\t\tdataPath,\n\t\t\t\t\tformat,\n\t\t\t\t\toneOfPath,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdataPath.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\t// If schema for array is a tuple\n\t\tif (Array.isArray(_schemaProp?.items)) {\n\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\t(object[key] as unknown[])[i] = convertScalarValue(\n\t\t\t\t\tvalue[i],\n\t\t\t\t\t_schemaProp.items[i].format as string,\n\t\t\t\t\tformat,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdataPath.pop();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\n\n/**\n * Converts the data to the specified format\n * @param data - data to convert\n * @param schema - The JSON schema that describes the structure of the data\n * @param dataPath - A string array that specifies the path to the data within the JSON schema\n * @param format  - The format to be converted to\n * @param oneOfPath - An optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns - The data converted to the specified format\n */\nexport const convert = (\n\tdata: Record<string, unknown> | unknown[] | unknown,\n\tschema: JsonSchema,\n\tdataPath: string[],\n\tformat: DataFormat,\n\toneOfPath: [string, number][] = [],\n) => {\n\t// If it's a scalar value\n\tif (!isObject(data) && !Array.isArray(data)) {\n\t\treturn convertScalarValue(data, schema?.format as string, format);\n\t}\n\n\tconst object = data as Record<string, unknown>;\n\t// case when schema is array and `items` is object\n\tif (\n\t\tArray.isArray(object) &&\n\t\tschema?.type === 'array' &&\n\t\t(schema?.items as JsonSchema)?.type === 'object'\n\t) {\n\t\tconvertArray({\n\t\t\tvalue: object,\n\t\t\tschemaProp: schema,\n\t\t\tschema,\n\t\t\tobject,\n\t\t\tkey: '',\n\t\t\tdataPath,\n\t\t\tformat,\n\t\t\toneOfPath,\n\t\t});\n\t} else {\n\t\tfor (const [key, value] of Object.entries(object)) {\n\t\t\tdataPath.push(key);\n\t\t\tlet schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);\n\n\t\t\t// If value is a scaler value\n\t\t\tif (isNullish(schemaProp)) {\n\t\t\t\tdelete object[key];\n\t\t\t\tdataPath.pop();\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If value is an object, recurse into it\n\t\t\tif (isObject(value)) {\n\t\t\t\tconvert(value, schema, dataPath, format, oneOfPath);\n\t\t\t\tdataPath.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If value is an array\n\t\t\tif (\n\t\t\t\tconvertArray({\n\t\t\t\t\tvalue,\n\t\t\t\t\tschemaProp,\n\t\t\t\t\tschema,\n\t\t\t\t\tobject,\n\t\t\t\t\tkey,\n\t\t\t\t\tdataPath,\n\t\t\t\t\tformat,\n\t\t\t\t\toneOfPath,\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The following code is basically saying:\n\t\t\t// if the schema specifies oneOf, then we are to loop\n\t\t\t// over each possible schema and check if they type of the schema specifies format\n\t\t\t// and if so we use the oneOfSchemaProp as the schema for formatting\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n\t\t\tif (schemaProp?.format === undefined && schemaProp?.oneOf !== undefined) {\n\t\t\t\tfor (const [_index, oneOfSchemaProp] of schemaProp.oneOf.entries()) {\n\t\t\t\t\tif (oneOfSchemaProp?.format !== undefined) {\n\t\t\t\t\t\tschemaProp = oneOfSchemaProp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tobject[key] = convertScalarValue(value, schemaProp.format as string, format);\n\n\t\t\tdataPath.pop();\n\t\t}\n\t}\n\n\treturn object;\n};\n\n/**\n * Given data that can be interpreted according to the provided schema, returns equivalent data that has been formatted\n * according to the provided return format.\n *\n * @param schema - how to interpret the data\n * @param data - data to be formatted\n * @param returnFormat - how to format the data\n * @returns - formatted data\n *\n * @example\n *\n * ```js\n * import { FMT_NUMBER, utils } from \"web3\";\n *\n * console.log(\n *   utils.format({ format: \"uint\" }, \"221\", { number: FMT_NUMBER.HEX }),\n * );\n * // 0xdd\n * ```\n *\n */\nexport const format = <\n\tDataType extends Record<string, unknown> | unknown[] | unknown,\n\tReturnType extends DataFormat,\n>(\n\tschema: ValidationSchemaInput | JsonSchema,\n\tdata: DataType,\n\treturnFormat: ReturnType = DEFAULT_RETURN_FORMAT as ReturnType,\n): FormatType<DataType, ReturnType> => {\n\tlet dataToParse: Record<string, unknown> | unknown[] | unknown;\n\n\tif (isObject(data)) {\n\t\tdataToParse = mergeDeep({}, data);\n\t} else if (Array.isArray(data)) {\n\t\tdataToParse = [...data];\n\t} else {\n\t\tdataToParse = data;\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\tconst jsonSchema: JsonSchema = isObject(schema) ? schema : utils.ethAbiToJsonSchema(schema);\n\n\tif (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {\n\t\tthrow new FormatterError('Invalid json schema for formatting');\n\t}\n\n\treturn convert(dataToParse, jsonSchema, [], returnFormat) as FormatType<\n\t\ttypeof data,\n\t\tReturnType\n\t>;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}