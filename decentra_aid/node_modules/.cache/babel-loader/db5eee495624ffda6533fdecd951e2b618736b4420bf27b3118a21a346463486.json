{"ast":null,"code":"\"use strict\";\n\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WORD_SIZE = void 0;\nexports.alloc = alloc;\nexports.allocUnsafe = allocUnsafe;\nexports.convertExternalAbiParameter = convertExternalAbiParameter;\nexports.isAbiParameter = isAbiParameter;\nexports.toAbiParams = toAbiParams;\nexports.extractArrayType = extractArrayType;\nexports.isDynamic = isDynamic;\nconst abitype_1 = require(\"abitype\");\nconst web3_errors_1 = require(\"web3-errors\");\nconst web3_utils_1 = require(\"web3-utils\");\nconst utils_js_1 = require(\"../utils.js\");\nexports.WORD_SIZE = 32;\nfunction alloc(size = 0) {\n  var _a;\n  if (((_a = globalThis.Buffer) === null || _a === void 0 ? void 0 : _a.alloc) !== undefined) {\n    const buf = globalThis.Buffer.alloc(size);\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n  return new Uint8Array(size);\n}\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nfunction allocUnsafe(size = 0) {\n  var _a;\n  if (((_a = globalThis.Buffer) === null || _a === void 0 ? void 0 : _a.allocUnsafe) !== undefined) {\n    const buf = globalThis.Buffer.allocUnsafe(size);\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n  return new Uint8Array(size);\n}\nfunction convertExternalAbiParameter(abiParam) {\n  var _a, _b;\n  return Object.assign(Object.assign({}, abiParam), {\n    name: (_a = abiParam.name) !== null && _a !== void 0 ? _a : '',\n    components: (_b = abiParam.components) === null || _b === void 0 ? void 0 : _b.map(c => convertExternalAbiParameter(c))\n  });\n}\nfunction isAbiParameter(param) {\n  return !(0, web3_utils_1.isNullish)(param) && typeof param === 'object' && !(0, web3_utils_1.isNullish)(param.type) && typeof param.type === 'string';\n}\nfunction toAbiParams(abi) {\n  return abi.map(input => {\n    var _a;\n    if (isAbiParameter(input)) {\n      return input;\n    }\n    if (typeof input === 'string') {\n      return convertExternalAbiParameter((0, abitype_1.parseAbiParameter)(input.replace(/tuple/, '')));\n    }\n    if ((0, utils_js_1.isSimplifiedStructFormat)(input)) {\n      const structName = Object.keys(input)[0];\n      const structInfo = (0, utils_js_1.mapStructNameAndType)(structName);\n      structInfo.name = (_a = structInfo.name) !== null && _a !== void 0 ? _a : '';\n      return Object.assign(Object.assign({}, structInfo), {\n        components: (0, utils_js_1.mapStructToCoderFormat)(input[structName])\n      });\n    }\n    throw new web3_errors_1.AbiError('Invalid abi');\n  });\n}\nfunction extractArrayType(param) {\n  const arrayParenthesisStart = param.type.lastIndexOf('[');\n  const arrayParamType = param.type.substring(0, arrayParenthesisStart);\n  const sizeString = param.type.substring(arrayParenthesisStart);\n  let size = -1;\n  if (sizeString !== '[]') {\n    size = Number(sizeString.slice(1, -1));\n    // eslint-disable-next-line no-restricted-globals\n    if (isNaN(size)) {\n      throw new web3_errors_1.AbiError('Invalid fixed array size', {\n        size: sizeString\n      });\n    }\n  }\n  return {\n    param: {\n      type: arrayParamType,\n      name: '',\n      components: param.components\n    },\n    size\n  };\n}\n/**\n * Param is dynamic if it's dynamic base type or if some of his children (components, array items)\n * is of dynamic type\n * @param param\n */\nfunction isDynamic(param) {\n  var _a, _b;\n  if (param.type === 'string' || param.type === 'bytes' || param.type.endsWith('[]')) return true;\n  if (param.type === 'tuple') {\n    return (_b = (_a = param.components) === null || _a === void 0 ? void 0 : _a.some(isDynamic)) !== null && _b !== void 0 ? _b : false;\n  }\n  if (param.type.endsWith(']')) {\n    return isDynamic(extractArrayType(param).param);\n  }\n  return false;\n}","map":{"version":3,"names":["exports","alloc","allocUnsafe","convertExternalAbiParameter","isAbiParameter","toAbiParams","extractArrayType","isDynamic","abitype_1","require","web3_errors_1","web3_utils_1","utils_js_1","WORD_SIZE","size","_a","globalThis","Buffer","undefined","buf","Uint8Array","buffer","byteOffset","byteLength","abiParam","Object","assign","name","components","_b","map","c","param","isNullish","type","abi","input","parseAbiParameter","replace","isSimplifiedStructFormat","structName","keys","structInfo","mapStructNameAndType","mapStructToCoderFormat","AbiError","arrayParenthesisStart","lastIndexOf","arrayParamType","substring","sizeString","Number","slice","isNaN","endsWith","some"],"sources":["/home/ubuntu/node_modules/web3-eth-abi/src/coders/utils.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { AbiParameter as ExternalAbiParameter, parseAbiParameter } from 'abitype';\nimport { AbiError } from 'web3-errors';\nimport { AbiInput, AbiParameter, AbiStruct } from 'web3-types';\nimport { isNullish } from 'web3-utils';\nimport {\n\tisSimplifiedStructFormat,\n\tmapStructNameAndType,\n\tmapStructToCoderFormat,\n} from '../utils.js';\n\nexport const WORD_SIZE = 32;\n\nexport function alloc(size = 0): Uint8Array {\n\tif (globalThis.Buffer?.alloc !== undefined) {\n\t\tconst buf = globalThis.Buffer.alloc(size);\n\t\treturn new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n\t}\n\n\treturn new Uint8Array(size);\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe(size = 0): Uint8Array {\n\tif (globalThis.Buffer?.allocUnsafe !== undefined) {\n\t\tconst buf = globalThis.Buffer.allocUnsafe(size);\n\t\treturn new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n\t}\n\n\treturn new Uint8Array(size);\n}\n\nexport function convertExternalAbiParameter(abiParam: ExternalAbiParameter): AbiParameter {\n\treturn {\n\t\t...abiParam,\n\t\tname: abiParam.name ?? '',\n\t\tcomponents: (abiParam as { components: readonly AbiParameter[] }).components?.map(c =>\n\t\t\tconvertExternalAbiParameter(c),\n\t\t),\n\t};\n}\n\nexport function isAbiParameter(param: unknown): param is AbiParameter {\n\treturn (\n\t\t!isNullish(param) &&\n\t\ttypeof param === 'object' &&\n\t\t!isNullish((param as { type: unknown }).type) &&\n\t\ttypeof (param as { type: unknown }).type === 'string'\n\t);\n}\n\nexport function toAbiParams(abi: ReadonlyArray<AbiInput>): ReadonlyArray<AbiParameter> {\n\treturn abi.map(input => {\n\t\tif (isAbiParameter(input)) {\n\t\t\treturn input;\n\t\t}\n\t\tif (typeof input === 'string') {\n\t\t\treturn convertExternalAbiParameter(parseAbiParameter(input.replace(/tuple/, '')));\n\t\t}\n\n\t\tif (isSimplifiedStructFormat(input)) {\n\t\t\tconst structName = Object.keys(input)[0];\n\t\t\tconst structInfo = mapStructNameAndType(structName);\n\t\t\tstructInfo.name = structInfo.name ?? '';\n\t\t\treturn {\n\t\t\t\t...structInfo,\n\t\t\t\tcomponents: mapStructToCoderFormat(\n\t\t\t\t\tinput[structName as keyof typeof input] as unknown as AbiStruct,\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\t\tthrow new AbiError('Invalid abi');\n\t});\n}\n\nexport function extractArrayType(param: AbiParameter): { size: number; param: AbiParameter } {\n\tconst arrayParenthesisStart = param.type.lastIndexOf('[');\n\tconst arrayParamType = param.type.substring(0, arrayParenthesisStart);\n\tconst sizeString = param.type.substring(arrayParenthesisStart);\n\tlet size = -1;\n\tif (sizeString !== '[]') {\n\t\tsize = Number(sizeString.slice(1, -1));\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tif (isNaN(size)) {\n\t\t\tthrow new AbiError('Invalid fixed array size', { size: sizeString });\n\t\t}\n\t}\n\treturn {\n\t\tparam: { type: arrayParamType, name: '', components: param.components },\n\t\tsize,\n\t};\n}\n\n/**\n * Param is dynamic if it's dynamic base type or if some of his children (components, array items)\n * is of dynamic type\n * @param param\n */\nexport function isDynamic(param: AbiParameter): boolean {\n\tif (param.type === 'string' || param.type === 'bytes' || param.type.endsWith('[]')) return true;\n\tif (param.type === 'tuple') {\n\t\treturn param.components?.some(isDynamic) ?? false;\n\t}\n\tif (param.type.endsWith(']')) {\n\t\treturn isDynamic(extractArrayType(param).param);\n\t}\n\treturn false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}